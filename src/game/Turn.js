/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado
  License MIT. See README.md at the root of this distribution for full copyright
  and license information. Author Crawford Currie http://c-dot.co.uk*/

import { Tile } from "./Tile.js";
import { Move } from "./Move.js";

/**
 * Despite the name, a Turn is used not just as a historical record
 * of a player's turn (such as a play or a swap) but also for other
 * results from commands sent to the server, such as challenges.
 * @extends Move
 */
class Turn extends Move {
  /**
   * The 'type' of the turn.
   * @member {Turns}
   */
  type;

  /**
   * Key of the game
   * @member {Key}
   */
  gameKey;

  /**
   * Key of the player who has been affected by the turn. Normally
   * this is the player who made the Move that resulted in the Turn,
   * but in the case of a challenge it is the player who was
   * challenged.
   * @member {Key}
   */
  playerKey;

  /**
   * Key of the next player who's turn it is
   * @member {Key}
   */
  nextToGoKey;

  /**
   * Time the turn was finished, assigned by the server.
   * @member {number}
   */
  timestamp;

  /**
   * @param {Game} game the game this is a turn in.
   * @param {object} params parameters. Any field with the same name
   * as a member (or a member of {@linkcode Move}) will initialise
   * that member.
   */
  constructor(params) {
    super(params);

    this.gameKey = params.gameKey;
    this.type = params.type;
    this.playerKey = params.playerKey;
    this.nextToGoKey = params.nextToGoKey;
    this.timestamp = params.timestamp || Date.now();

    if (params.replacements)
      /**
       * List of tiles drawn from the bag to replace the tiles played
       * in this turn. These tiles will not have positions.
       * @member {Tile[]?}
       */
      this.replacements = params.replacements.map(
        tilespec => new Tile(tilespec));

    if (params.challengerKey)
      /**
       * For `Game.Turns.CHALLENGE_WON` and `Game.Turns.CHALLENGE_LOST`,
       * the key of the player who challenged. playerkey in this case
       * will be the player who's play was challenged (always the
       * previous player)
       * @member {Key?}
       */
      this.challengerKey = params.challengerKey;

    if (params.endState)
      /**
       * String describing the reason the game ended. Only used when
       * type==Game.Turns.GAME_ENDED
       * @member {State?}
       */
      this.endState = params.endState;

    if (params.passes && params.passes > 0)
      /**
       * Number of passes the player had before this play. Required
       * for undo.
       * @member {number?}
       */
      this.passes = params.passes;
  }

  /**
   * Create simple flat structure describing a subset of the turn
   * state. This is used for sending minimal turn information to
   * the `games` interface using JSON.
   */
  serialisable() {
    return {
      // Fields that are not used by the `games` interface are not
      // sent
      type: this.type,
      timestamp: this.timestamp
    };
  }

  /**
   * Construct a player object from a structure generated by
   * serialisable()
   * @param {object} simple object generated by serialisable()
   * @param {object} factory Game class to be used as factory
   */
  static fromSerialisable(simple, factory) {
    return new factory.Turn(simple);
  }

  /* c8 ignore start */

  /**
   * String representation for debugging
   */
  stringify() {
    let s = `Turn ${this.type} ${this.playerKey}`;
    if (this.challengerKey)
      s += ` by ${this.challengerKey}`;
    if (this.nextToGoKey && this.nextToGoKey !== this.playerKey)
      s += ` ->${this.nextToGoKey}`;

    if (typeof this.score === "object")
      s += ` (${this.score.tiles||0},${this.score.time||0})`;
    else if (typeof this.score === "number")
      s += ` (${this.score})`;

    if (this.placements)
      s += " place" + this.placements.map(t => t.stringify(true));

    if (this.words)
      s += ' "' + this.words.map(w => w.word) + '"';

    if (this.replacements)
      s += " replace" + this.replacements.map(t => t.stringify(true));

    if (this.penalty === "Miss next turn"/*Game.Penalty.MISS*/)
      s += ` MISS`;

    if (this.endState)
      s += ` ${this.endState}`;

    return s;
  }

  /* c8 ignore stop */
}

export { Turn }
