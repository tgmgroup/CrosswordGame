/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/backend lazy recursive":
/*!***************************************************!*\
  !*** ./src/backend/ lazy strict namespace object ***!
  \***************************************************/
/***/ ((module) => {

eval("function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./src/backend lazy recursive\";\nmodule.exports = webpackEmptyAsyncContext;\n\n//# sourceURL=webpack://@cdot/xanado/./src/backend/_lazy_strict_namespace_object?");

/***/ }),

/***/ "./src/backend/BackendGame.js":
/*!************************************!*\
  !*** ./src/backend/BackendGame.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BackendGame\": () => (/* binding */ BackendGame)\n/* harmony export */ });\n/* harmony import */ var _game_Game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game.js */ \"./src/game/Game.js\");\n/* harmony import */ var _game_Undo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/Undo.js */ \"./src/game/Undo.js\");\n/* harmony import */ var _game_Replay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game/Replay.js */ \"./src/game/Replay.js\");\n/* harmony import */ var _game_Commands_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../game/Commands.js */ \"./src/game/Commands.js\");\n/*Copyright (C) 2021-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n\n\n\n\n\n/**\n * Back end implementation of {@linkcode Game}.\n * Combines all the game components into a playable game.\n * @mixes game/Undo\n * @mixes game/Replay\n * @mixes game/Commands\n * @extends Game\n */\nclass BackendGame extends (0,_game_Undo_js__WEBPACK_IMPORTED_MODULE_1__.Undo)((0,_game_Replay_js__WEBPACK_IMPORTED_MODULE_2__.Replay)((0,_game_Commands_js__WEBPACK_IMPORTED_MODULE_3__.Commands)(_game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game))) {\n\n  /**\n   * Override factory classes from Game\n   */\n  static CLASSES = {\n    Game: BackendGame,\n\n    Board: _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Board,\n    Square: _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Square,\n    Tile: _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Tile,\n    Player: _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Player,\n    Rack: _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Rack,\n    LetterBag: _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.LetterBag,\n    Move: _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Move,\n    Turn: _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Turn\n  };\n\n  /**\n   * Check if the game has timed out due to inactivity.\n   * Stops game timers and sets the state of the game if it has.\n   * @param {integer} limit the maximum time since the game was last\n   * interacted with (played) in milliseconds. If the limit is <= 0\n   * then games never time out.\n   * @return {Promise} resolves to the game when timeout has\n   * been checked\n   */\n  checkAge(limit) {\n    if (limit > 0 && Date.now() - this.lastActivity() > limit) {\n\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"Game\", this.key, \"timed out\");\n\n      this.state = _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.State.TIMED_OUT;\n      return this.save();\n    }\n    return Promise.resolve(this);\n  }\n}\n\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/backend/BackendGame.js?");

/***/ }),

/***/ "./src/backend/findBestPlayWorker.js":
/*!*******************************************!*\
  !*** ./src/backend/findBestPlayWorker.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _BackendGame_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BackendGame.js */ \"./src/backend/BackendGame.js\");\n/* harmony import */ var _game_findBestPlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/findBestPlay.js */ \"./src/game/findBestPlay.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/* global postMessage */\n/* global addEventListener */\n/* global close */\n/* global window */\n/* global global */\n\n\n\n\n/**\n * Worker thread for findBestPlay. This allows the best play to be\n * found asynchronously, without blocking the main thread, so we can\n * time it out if necessary. Simply calls {@linkcode module:game/findBestPlay}\n * @module\n */\n\nfunction send(type, data) {\n  postMessage(\n    _BackendGame_js__WEBPACK_IMPORTED_MODULE_0__.BackendGame.toCBOR({ type: type, data: data }));\n}\n\naddEventListener(\"message\", event => {\n  const info = _BackendGame_js__WEBPACK_IMPORTED_MODULE_0__.BackendGame.fromCBOR(event.data, _BackendGame_js__WEBPACK_IMPORTED_MODULE_0__.BackendGame.CLASSES);\n  const platf = info.Platform == \"ServerPlatform\"\n        ? \"../server/ServerPlatform.js\"\n        : \"../browser/BrowserPlatform.js\";\n  __webpack_require__(\"./src/backend lazy recursive\")(platf)\n  .then(mod => {\n    if (typeof global === \"undefined\")\n      window.Platform = mod[info.Platform];\n    else\n      global.Platform = mod[info.Platform];\n    (0,_game_findBestPlay_js__WEBPACK_IMPORTED_MODULE_1__.findBestPlay)(\n      info.game, info.rack,\n      bestPlay => send(\"play\", bestPlay),\n      info.dictionary)\n    .then(() => {\n      send(\"exit\");\n      close();\n    });\n  });\n});\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/backend/findBestPlayWorker.js?");

/***/ }),

/***/ "./src/common/Fridge.js":
/*!******************************!*\
  !*** ./src/common/Fridge.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Fridge\": () => (/* binding */ Fridge)\n/* harmony export */ });\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\nconst IB_ID = \"_\\u00CD\";\nconst IB_CN = \"_\\u0106\";\nconst IB_DATA = \"_\\u00D0\";\nconst IB_REF = \"_\\u0154\";\n\n/**\n * OLD CODE, now maintained just for compatibility.\n * Use {@linkcode CBOR} instead.\n *\n * Simple serialisation/deserialisation of a JS object\n * graph to stand-alone JSON. Does not handle function\n * references. Full restoration of objects requires classes\n * to be passed in to thaw().\n *\n * Classes passed in can optionally define methods \"Freeze()\" and\n * \"static Thaw()\". Freeze must return frozen data for the object,\n * that will then be thawed by calling Thaw, which is passed the\n * frozen data. It is entirely up to the class how Freeze and Thaw\n * are implemented.\n *\n * The object properties above are reserved for use by this\n * module, and note also that fields who's names start with _ will\n * not be serialised.\n *\n * Note that the objects being frozen are 'interfered with' by the\n * addition of an IB_ID field that indicates their 'frozen ID'.\n * This is a (clumsy) solution to the lack of ES7 value objects in ES6.\n * The frozen version (JSONified) version of objects are decorated\n * with fields as follows:\n * IB_CN: constructor name\n * IB_REF: the IB_ID of another object being referenced\n * Date objects are serialised to string.\n *\n * If the class of an object has the UNFREEZABLE attribute, then\n * the name of that class won't be frozen. Instead the identifier of\n * the superclass will be used (ultimately, Object).\n * @deprecated since version 3.1.0\n */\nclass Fridge {\n\n  /**\n   * Convert an object graph to stand-alone JSON.\n   * @param {object} object - object to freeze\n   * @return {object} the frozen version of the object\n   * @deprecated since version 3.1.0\n   */\n  static freeze(object) {\n    const objectsFrozen = [];\n\n    function _freeze(unfrozen) {\n      // Can't/don't want to serialise functions\n      /* c8 ignore start */\n      if (typeof unfrozen === \"function\")\n        throw Error(\"Can't freeze functions\");\n      /* c8 ignore stop */\n\n      if (!unfrozen || typeof unfrozen !== \"object\")\n        return unfrozen;\n\n      // better way to handle arrays\n      if (Array.isArray(unfrozen)) {\n        return unfrozen.map(e => _freeze(e));\n      }\n\n      try {\n        if (Object.prototype.hasOwnProperty.call(unfrozen, IB_ID)) {\n          // ref to a previously frozen object\n          if (unfrozen.constructor) {\n            //console.debug(`Ref to ${unfrozen[IB_ID]} ${unfrozen.constructor.name}`);\n            const ret = {}; ret[IB_REF] = unfrozen[IB_ID];\n            return ret;\n          }\n        }\n      /* c8 ignore start */\n      } catch (e) {\n        throw new Error(\"Corrupt fridge\");\n      }\n      /* c8 ignore stop */\n      const id = objectsFrozen.length;\n      // Working property will be removed later\n      Object.defineProperty(unfrozen, IB_ID, {\n        configurable: true,\n        value: id\n      });\n      objectsFrozen.push(unfrozen);\n\n      const frozen = {};\n      frozen[IB_ID] = id;\n\n      if (unfrozen.constructor\n          && unfrozen.constructor.name\n          && unfrozen.constructor.name !== \"Object\")\n      {\n        let freezable = unfrozen.constructor;\n        // The static UNFREEZABLE attribute on a class indicates that\n        // the superclass should be used in the freeze\n        while (freezable.UNFREEZABLE) {\n          //console.log(freezable, \"unfreezable\");\n          freezable = Object.getPrototypeOf(freezable);\n          if (freezable.name === \"Object\")\n            throw Error(\"Bottomless unfreezable chain\");\n        }\n        frozen[IB_CN] = freezable.name;\n      }\n\n      const proto = Object.getPrototypeOf(unfrozen);\n      if (proto && typeof proto.Freeze === \"function\") {\n        frozen[IB_DATA] = unfrozen.Freeze();\n\n      } else if (frozen[IB_CN] === \"Date\") {\n        // Special handling because the fields are just noise\n        frozen[IB_DATA] = unfrozen.getTime();\n        return frozen;\n\n      } else {\n        frozen[IB_DATA] = {};\n        for (let prop in unfrozen)\n          // Exclude _* to avoid _events etc\n          // Don't try to freeze code, might overwrite mixins\n          if (!/^#?_/.test(prop) && typeof unfrozen[prop] !== \"function\") {\n            try {\n              frozen[IB_DATA][prop] = _freeze(unfrozen[prop]);\n            /* c8 ignore start */\n            } catch (e) {\n              debugger;\n            }\n            /* c8 ignore stop */\n          }\n      }\n      return frozen;\n    }\n\n    const frozen = _freeze(object);\n    // Clean out temporary fields used in freezing\n    for (let uf of objectsFrozen)\n      delete uf[IB_ID];\n\n    return JSON.stringify(frozen, null, 1);\n  }\n\n  /**\n   * Expand a frozen structure. During freezing, the\n   * constructor name for each frozen object is recorded. During\n   * thawing, that constructor name has to be mapped to a\n   * prototype. If a useable constructor is not found, a\n   * warning will be printed to the console.\n   * @param {string|buffer} json JSON of object to thaw\n   * @param {object.<string,object>} typeMap optional map from class name\n   * to class for objects expected within frozen data.\n   * @deprecated since version 3.1.0\n   */\n  static thaw(json, typeMap) {\n    const objectsThawed = [];\n\n    function _thaw(object) {\n      if (!object || typeof object !== \"object\")\n        return object;\n\n      if (Array.isArray(object)) {\n        return object.map(e => _thaw(e));\n      }\n\n      if (Object.prototype.hasOwnProperty.call(object, IB_REF)) {\n        // Reference to another object, that must already have\n        // been thawed\n        if (objectsThawed[object[IB_REF]])\n          return objectsThawed[object[IB_REF]];\n        /* c8 ignore next */\n        throw new Error(`reference to unthawed ${object[IB_REF]}`);\n      }\n\n      let thawed, thawProps = false;\n      let clzz = typeMap[object[IB_CN]];\n      if (object[IB_CN] === \"Date\")\n        // Special handling because we just serialise an integer\n        return new Date(object[IB_DATA]);\n\n      else if (clzz) {\n        if (typeof clzz.Thaw === \"function\")\n          thawed = clzz.Thaw(object[IB_DATA]);\n        else {\n          thawed = Object.create(clzz.prototype);\n          thawProps = true;\n        }\n\n      } else {\n        if (object[IB_CN])\n          throw Error(`${object[IB_CN]} missing from type map`);\n        thawed = {};\n        thawProps = true;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(object, IB_ID))\n        objectsThawed[object[IB_ID]] = thawed;\n\n      if (thawProps)\n        for (let prop in object[IB_DATA]) {\n          thawed[prop] = _thaw(\n            object[IB_DATA][prop], objectsThawed);\n        }\n\n      return thawed;\n    }\n\n    const object = JSON.parse(json);\n    return _thaw(object);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/common/Fridge.js?");

/***/ }),

/***/ "./src/common/Utils.js":
/*!*****************************!*\
  !*** ./src/common/Utils.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"genKey\": () => (/* binding */ genKey),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify)\n/* harmony export */ });\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/** @module */\n\n/**\n * Generate a unique 16-character key using a-z0-9\n * @param {string[]?} miss optional array of pregenerated keys to miss\n * @return {string} a key not already in miss\n */\nfunction genKey(miss) {\n  const chs = \"0123456789abcdef\".split(\"\");\n  if (miss) {\n    let key;\n    do {\n      key = genKey();\n    } while (key in miss);\n    return key;\n  }\n  const s = [];\n  for (let i = 0; i < 16; i++)\n    s.push(chs[Math.floor(Math.random() * 16)]);\n  return s.join(\"\");\n}\n\n/**\n * Generate readable (though not parseable) representation of object,\n * for use in debugging. Easier to read than JSON.stringify. Used instead\n * of toString() and valueOf() which are inconsistent between platforms.\n */\nfunction stringify(value) {\n  // Based on Crockford's polyfill for JSON.stringify.\n\n  switch (typeof value) {\n  case \"undefined\":\n    return \"?\";\n  case \"string\":\n    return `\"${value}\"`;\n  case \"number\":\n  case \"boolean\":\n  case \"null\":\n    return String(value);\n  }\n\n  // Due to a specification blunder in ECMAScript,\n  // typeof null is \"object\"\n  if (!value)\n    return \"null\";\n\n  // Use the stringify function, if the object has one.\n  if (typeof value === \"object\"\n      && typeof value.stringify === \"function\")\n    return value.stringify();\n\n  const partial = [];\n\n  // Built-in types\n  if (value instanceof Date)\n    return value.toISOString();\n\n  // Is the value an array?\n  if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n    for (const v of value)\n      partial.push(stringify(v));\n\n    return `[${partial.join(\",\")}]`;\n  }\n\n  // Otherwise this is an object\n  for (const k in value) {\n    if (Object.prototype.hasOwnProperty.call(value, k)) {\n      const v = stringify(value[k]);\n      if (v)\n        partial.push(`${k}:${v}`);\n    }\n  }\n  return `{${partial.join(\",\")}}`;\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/common/Utils.js?");

/***/ }),

/***/ "./src/game/Board.js":
/*!***************************!*\
  !*** ./src/game/Board.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Board\": () => (/* binding */ Board)\n/* harmony export */ });\n/* harmony import */ var _Surface_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Surface.js */ \"./src/game/Surface.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/* global assert */\n\n\n\n/**\n * The square game board.\n */\nclass Board extends _Surface_js__WEBPACK_IMPORTED_MODULE_0__.Surface {\n\n  /**\n   * Row of middle square on board.\n   * @member {number}\n   */\n  midrow = -1;\n\n  /**\n   * Column of middle square on board.\n   * @member {number}\n   */\n  midcol = -1;\n\n  /**\n   * @param {object} factory class object mapping class name to a class\n   * @param {Edition|Board} spec an Edition defining the board layout,\n   * or a Board to copy. The tiles on the old board will NOT be copied.\n   */\n  constructor(factory, spec) {\n    const info = {\n      id: \"Board\",\n      rows: spec.rows,\n      cols: spec.cols\n    };\n    if (spec instanceof Board)\n      info.type = (col, row) => spec.at(col, row).type;\n    else // if (spec instanceof Edition)\n      info.type = (col, row) => spec.squareType(col, row);\n\n    super(factory, info);\n\n    this.midrow = Math.floor(this.rows / 2);\n    this.midcol = Math.floor(this.cols / 2);\n  }\n\n  /**\n   * Determine if any any unlocked tiles are placed on the board.\n   * @return {boolean} true if there are placed but unlocked tiles\n   */\n  hasUnlockedTiles() {\n    return this.forEachTiledSquare(sq => (!sq.tile.isLocked));\n  }\n\n  /**\n   * Populate the board from a string output by\n   * {@linkcode Board#toString|toString}. This is for use in tests.\n   * @param {object} factory object giving Game classes to instantiate\n   * @param {Edition} edition the edition defining the board layout.\n   * This has to be provided because we don't cache the actual\n   * Edition in the Board.\n   * @param {string} tiles string representation of the board\n   * @private\n   */\n  parse(factory, edition, tiles) {\n    const rows = tiles.split(\"\\n\");\n    assert(rows.length >= this.rows, \"Too many rows\");\n    for (let row = 0; row < this.rows; row++) {\n      const r = rows[row].split(\"|\");\n      assert(r.length === this.cols + 2,\n             `${r.length} === ${this.cols} + 2`);\n      for (let col = 0; col < this.cols; col++) {\n        const letter = r[col + 1];\n        if (letter != \" \") {\n          // Treat lower-case letters as cast blanks.\n          // May not work in non-latin languages.\n          const isBlank = (letter.toUpperCase() != letter);\n          const tile = new factory.Tile({\n            letter: letter.toUpperCase(),\n            isBlank: isBlank,\n            score: isBlank ? 0 : edition.letterScore(letter)\n          });\n          this.at(col, row).placeTile(tile, true);\n        }\n      }\n    }\n  }\n\n  /**\n   * True if one of the neighbours of [col, row] is already occupied by\n   * a tile that was placed in a previous move\n   * @param {number} col 0-based row\n   * @param {number} row 0-based row\n   */\n  touchingOld(col, row) {\n    return (\n      (col > 0 && this.at(col - 1, row).tile\n       && this.at(col - 1, row).hasLockedTile())\n      || (col < this.cols - 1 && this.at(col + 1, row).tile\n          && this.at(col + 1, row).hasLockedTile())\n      || (row > 0 && this.at(col, row - 1).tile\n          && this.at(col, row - 1).hasLockedTile())\n      || (row < this.rows - 1 && this.at(col, row + 1).tile\n          && this.at(col, row + 1).hasLockedTile()));\n  }\n\n  /* c8 ignore start */\n\n  /**\n   * Generate a string representation of the board in the format\n   * readable by {@linkcode Board#parse|parse}\n   * @override\n   */\n  stringify() {\n    let s = \"\";\n\n    for (let row = 0; row < this.rows; row++) {\n      const r = [];\n      for (let col = 0; col < this.cols; col++) {\n        const square = this.at(col, row);\n        const t = square.tile;\n        if (t) {\n          // Show cast blanks using lower case letters\n          // May not work in non-Latin languages.\n          if (t.isBlank)\n            r.push(t.letter.toLowerCase());\n          else\n            r.push(t.letter);\n        } else {\n          if ((square.letterScoreMultiplier || 0) > 1)\n            r.push(square.letterScoreMultiplier);\n          else if ((square.wordScoreMultiplier || 0) > 1)\n            r.push(4 + square.wordScoreMultiplier);\n          else\n            r.push(\" \");\n        }\n      }\n      s += `|${r.join(\"|\")}|\\n`;\n    }\n    return s;\n  }\n\n  /* c8 ignore stop */\n\n  /**\n   * Given a play at col, row, compute it's score. Used in\n   * findBestPlay, and must perform as well as possible. Read\n   * the description of {@linkcode Board#analysePlay|analysePlay}\n   * to understand the difference between these two related functions.\n   * Note: does *not* include any bonuses due to number of tiles played.\n   * @param {number} col the col of the LAST letter\n   * @param {number} row the row of the LAST letter\n   * @param {number} dcol 1 if the word being played across\n   * @param {number} drow 1 if the word is being played down\n   * @param {Tile[]} tiles a list of tiles that are being placed\n   * @param {string[]?} words optional list to be populated with\n   * words that have been created by the play\n   * @return {number} the score of the play.\n   */\n  scorePlay(col, row, dcol, drow, tiles, words) {\n    //console.debug(`scorePlay(${col},${row},${dcol},${drow},`,\n    //            tiles.map(t => t.stringify()).join(\";\"));\n    // Accumulator for the primary word being formed by the tiles\n    let wordScore = 0;\n\n    // Accumulator for crossing words scores.\n    let crossWordsScore = 0;\n\n    // Multipler for the main word\n    let wordMultiplier = 1;\n\n    // One behind first tile offset\n    let c = col - dcol * tiles.length;\n    let r = row - drow * tiles.length;\n\n    for (let i = 0; i < tiles.length; i++) {\n      c += dcol;\n      r += drow;\n      const tile = tiles[i];\n      let letterScore = tile.score;\n      const square = this.at(c, r);\n      if (square.hasLockedTile()) {\n        wordScore += letterScore;\n        continue; // pre-existing tile, no bonuses\n      }\n\n      // Letter is being placed, so letter multiplier applies to all\n      // new words created, including cross words\n      letterScore *= (square.letterScoreMultiplier || 1);\n\n      wordScore += letterScore;\n\n      // Multiplier for any new words that cross this letter\n      const crossWordMultiplier = (square.wordScoreMultiplier || 1);\n      wordMultiplier *= crossWordMultiplier;\n\n      // This is a new tile, need to analyse cross words and\n      // apply bonuses\n      let crossWord = \"\";\n      let crossWordScore = 0;\n\n      // Look left/up\n      for (let cp = c - drow, rp = r - dcol;\n           cp >= 0 && rp >= 0 && this.at(cp, rp).tile;\n           cp -= drow, rp -= dcol) {\n        const tile = this.at(cp, rp).tile;\n        crossWord = tile.letter + crossWord;\n        crossWordScore += tile.score;\n      }\n\n      crossWord += tile.letter;\n\n      // Look right/down\n      for (let cp = c + drow, rp = r + dcol;\n           cp < this.cols && rp < this.rows\n           && this.at(cp, rp).tile;\n           cp += drow, rp += dcol) {\n        const tile = this.at(cp, rp).tile;\n        crossWord += tile.letter;\n        crossWordScore += tile.score;\n      }\n\n      if (crossWordScore > 0) {\n        // This tile (and bonuses) contribute to cross words\n        crossWordScore += letterScore;\n        crossWordScore *= crossWordMultiplier;\n        if (words)\n          words.push({\n            word: crossWord,\n            score: crossWordScore\n          });\n\n        crossWordsScore += crossWordScore;\n      }\n    }\n\n    wordScore *= wordMultiplier;\n\n    if (words)\n      words.push({\n        word: tiles.map(tile => tile.letter).join(\"\"),\n        score: wordScore\n      });\n\n    // Add cross word values to the main word value\n    wordScore += crossWordsScore;\n\n    return wordScore;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Board.js?");

/***/ }),

/***/ "./src/game/Commands.js":
/*!******************************!*\
  !*** ./src/game/Commands.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Commands\": () => (/* binding */ Commands)\n/* harmony export */ });\n/* harmony import */ var _common_Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Utils.js */ \"./src/common/Utils.js\");\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Game.js */ \"./src/game/Game.js\");\n/*Copyright (C) 2021-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/* global assert */\n\n\n\n\n/**\n * Mixin to {@linkcode Game} that provides handlers for game\n * commands.\n * @mixin game/Commands\n */\nconst Commands = superclass => class extends superclass {\n\n  /**\n   * Place tiles on the board.\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player player requesting the move\n   * @param {Move} move a Move (or the spec of a Move)\n   * @return {Promise} resolving to a the game\n   */\n  async play(player, move) {\n    assert(move, \"No move\");\n    assert(player && player.key === this.whosTurnKey,\n           `Not ${player.name}'s turn`);\n\n    /* c8 ignore next 4 */\n    if (this._debug) {\n      this._debug(\"Playing\", (0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_0__.stringify)(move));\n      this._debug(`Player's rack is ${player.rack.stringify()}`);\n    }\n\n    if (this.dictionary\n        && !this.isRobot\n        && this.wordCheck === _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.WordCheck.REJECT) {\n\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"Validating play\");\n\n      // Check the play in the dictionary, and generate a\n      // 'reject' if it's bad. This has to be done\n      // synchronously before we start modifying the board\n      // state.\n      let badWords = [];\n      await this.getDictionary()\n      .then(dict => {\n        for (let w of move.words) {\n          if (!dict.hasWord(w.word))\n            badWords.push(w.word);\n        }\n      });\n      if (badWords.length > 0) {\n        /* c8 ignore next 2 */\n        if (this._debug)\n          this._debug(\"\\trejecting\", badWords);\n        // Reject the play. Nothing has been done to the\n        // game state yet, so we can just ping the\n        // player back and let the UI sort it out.\n        this.notifyPlayer(\n          player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.REJECT,\n          {\n            playerKey: player.key,\n            words: badWords\n          });\n        return Promise.resolve();\n      }\n    }\n\n    if (player.wantsAdvice) {\n      // 'Post-move' alternatives analysis.\n      // Do this before we place the tiles\n      // on the board, so that the game and tiles get frozen\n      // and passed to the findBestPlayWorker.\n      await this.advise(player, move.score);\n    }\n\n    // Move tiles from the rack to the board\n    assert(move.placements, \"No placements\");\n    this.rackToBoard(move.placements, player);\n\n    player.score += move.score;\n\n    //console.debug(\"words \", move.words);\n\n    if (this.dictionary\n        && this.wordCheck === _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.WordCheck.AFTER\n        && !player.isRobot) {\n      // Asynchronously check word and notify player if it\n      // isn't found.\n      this.getDictionary()\n      .then(dict => {\n        if (move.words) {\n          for (let w of move.words) {\n            /* c8 ignore next 2 */\n            if (this._debug)\n              this._debug(\"Checking \",w);\n            if (!dict.hasWord(w.word)) {\n              // Only want to notify the player\n              this.notifyPlayer(\n                player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE,\n                {\n                  sender: /*i18n*/\"Advisor\",\n                  text: /*i18n*/\"word-not-found\",\n                  args: [ w.word, dict.name ]\n                });\n            }\n          }\n        }\n      });\n    }\n\n    const prepasses = player.passes;\n    player.passes = 0;\n\n    // Get new tiles to replace those placed\n    const replacements = [];\n    for (let i = 0; i < move.placements.length; i++) {\n      const tile = this.letterBag.getRandomTile();\n      if (tile) {\n        player.rack.addTile(tile);\n        replacements.push(tile);\n      }\n    }\n\n    // Report the result of the turn\n    const nextPlayer = this.nextPlayer();\n    this.whosTurnKey = nextPlayer.key;\n    return this.finishTurn(player, {\n      type: _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PLAYED,\n      nextToGoKey: nextPlayer.key,\n      score: move.score,\n      placements: move.placements,\n      replacements: replacements,\n      words: move.words,\n      passes: prepasses\n    })\n    .then(() => this.startTurn(nextPlayer));\n  }\n\n  /**\n   * Pause the game\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player to play\n   * @return {Promise} resolving to the game\n   */\n  pause(player) {\n    if (this.pausedBy)\n      return Promise.resolve(this); // already paused\n    this.stopTheClock();\n    this.pausedBy = player.name;\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(`${this.pausedBy} has paused game`);\n    this.notifyAll(_Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.PAUSE, {\n      key: this.key,\n      name: player.name,\n      timestamp: Date.now()\n    });\n    return this.save();\n  }\n\n  /**\n   * Unpause the game\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player to play\n   * @return {Promise} resolving to the game\n   */\n  unpause(player) {\n    /* c8 ignore next 2 */\n    if (!this.pausedBy)\n      return Promise.resolve(this); // not paused\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(`${player.name} has unpaused game`);\n    this.notifyAll(_Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.UNPAUSE, {\n      key: this.key,\n      name: player.name,\n      timestamp: Date.now()\n    });\n    this.pausedBy = undefined;\n    this.startTheClock();\n    return this.save();\n  }\n\n  /**\n   * Called when the game has been confirmed as over - the player\n   * following the player who just emptied their rack has confirmed\n   * they don't want to challenge, or they have challenged and the\n   * challenge failed.\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player player confirming end of game\n   * @param {string} endState gives reason why game ended\n   * (i18n message id) one of `Game.State.GAME_OVER`, `Game.State.TWO_PASSES`, or\n   * `Game.State.CHALLENGE_LOST`\n   * @return {Promise} resolving to undefined\n   */\n  confirmGameOver(player, endState) {\n    // If players pass twice then a game-over will be automatically\n    // handled in startTurn. We don't want to repeat the processing\n    // again.\n    if (this.state !== _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.PLAYING)\n      return Promise.resolve();\n\n    this.state = endState || _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.GAME_OVER;\n\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(`Confirming game over because ${this.state}`);\n    this.stopTheClock();\n\n    // When the game ends, each player's score is reduced by\n    // the sum of their unplayed letters. If a player has used\n    // all of his or her letters, the sum of the other players'\n    // unplayed letters is added to that player's score.\n    let playerWithNoTiles;\n    let pointsRemainingOnRacks = 0;\n    const deltas = {};\n    this.players.forEach(player => {\n      const delta = { key: player.key, tiles: 0 };\n      // Unless undo is enabled, the client receives redacted versions of\n      // the rack tiles. We have to send the actual tiles remaining on racks\n      // for the \"game ended\" message.\n      if (player.rack.isEmpty()) {\n        assert(\n          !playerWithNoTiles,\n          \"Found more than one player with no tiles when finishing game\");\n        playerWithNoTiles = player;\n      }\n      else {\n        const rackScore = player.rack.score();\n        player.score -= rackScore;\n        // Points lost for tiles remaining\n        delta.tiles -= rackScore;\n        // Tiles remaining on this player's rack\n        delta.tilesRemaining = player.rack.lettersLeft().join(\",\");\n        pointsRemainingOnRacks += rackScore;\n        /* c8 ignore next 2 */\n        if (this._debug)\n          this._debug(`\\t${player.name}: ${rackScore} points left ${delta.tilesRemaining}`);\n      }\n      if (this.timerType === _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Timer.GAME && player.clock < 0) {\n        const points = Math.round(\n          player.clock * this.timePenalty / 60);\n        /* c8 ignore next 2 */\n        if (this._debug)\n          this._debug(player.name, \"over by\", -player.clock,\n                    \"s, score\", points, \"points\");\n        if (points < 0)\n          delta.time = points;\n      }\n      deltas[player.key] = delta;\n    });\n\n    if (playerWithNoTiles) {\n      playerWithNoTiles.score += pointsRemainingOnRacks;\n      deltas[playerWithNoTiles.key].tiles = pointsRemainingOnRacks;\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(playerWithNoTiles.name, \"gains\", pointsRemainingOnRacks);\n    }\n    const factory = this.constructor.CLASSES;\n    return this.finishTurn(player, new factory.Turn({\n      type: _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.GAME_ENDED,\n      endState: endState,\n      score: Object.keys(deltas).map(k => deltas[k])\n    }));\n  }\n\n  /**\n   * Undo the last move. This might be as a result of a player request,\n   * or the result of a challenge.\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player if type==Game.Turns.CHALLENGE_WON this must be\n   * the challenging player. Otherwise it is the player taking their\n   * play back.\n   * @param {string} type the type of the takeBack; Game.Turns.TOOK_BACK\n   * or Game.Turns.CHALLENGE_WON.\n   * @return {Promise} Promise resolving to the game\n   */\n  takeBack(player, type) {\n    const previousMove = this.lastTurn();\n    assert(previousMove, \"No previous move to take back\");\n    assert(previousMove.type == _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PLAYED,\n           `Cannot challenge a ${previousMove.type}`);\n\n    const prevPlayer = this.getPlayerWithKey(previousMove.playerKey);\n\n    // Move tiles that were added to the rack as a consequence\n    // of the previous move, back to the letter bag\n    this.rackToBag(previousMove.replacements, prevPlayer);\n\n    // Move placed tiles from the board back to the player's rack\n    if (previousMove.placements)\n      this.boardToRack(previousMove.placements, prevPlayer);\n\n    prevPlayer.score -= previousMove.score;\n\n    const turn = {\n      type: type,\n      nextToGoKey: type === _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_WON\n      ? this.whosTurnKey : player.key,\n      score: -previousMove.score,\n      placements: previousMove.placements,\n      replacements: previousMove.replacements\n    };\n\n    if (type === _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_WON)\n      turn.challengerKey = player.key;\n\n    return this.finishTurn(prevPlayer, turn)\n    .then(() => {\n      if (type === _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.TOOK_BACK) {\n        // Let the taking-back player go again,\n        // but with just the remaining time from their move.\n        return this.startTurn(player, previousMove.remainingTime);\n      }\n      // Otherwise this is a CHALLENGE_WON, and the\n      // current player continues where they left off, but\n      // with their timer reset\n      return Promise.resolve(this);\n    });\n  }\n\n  /**\n   * Handler for 'pass' command.\n   * Player wants to (or has to) miss their move. Either they\n   * can't play, or challenged and failed.\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player player passing (must be current player)\n   * @param {string} type pass type, `Game.Turns.PASSED` or\n   * `Game.Turns.TIMED_OUT`. If undefined, defaults to `Game.Turns.PASSED`\n   * @return {Promise} resolving to the game\n   */\n  pass(player, type) {\n    assert(player.key === this.whosTurnKey,\n           `Not ${player.name}'s turn`);\n\n    player.passes++;\n\n    const nextPlayer = this.nextPlayer();\n\n    return this.finishTurn(player, {\n      type: type || _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PASSED,\n      nextToGoKey: nextPlayer.key\n    })\n    .then(() => this.startTurn(nextPlayer));\n  }\n\n  /**\n   * Handler for 'challenge' command.\n   * Check the words created by the previous move are in the dictionary\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} challenger player making the challenge\n   * @param {Player} challenged player being challenged\n   * @return {Promise} resolving to the game\n   */\n  challenge(challenger, challenged) {\n\n    assert(challenger.key !== challenged.key,\n           \"Cannot challenge your own play\");\n    assert(this.turns.length > 0,\n           \"No previous move to challenge\");\n\n    let previousMove = this.lastTurn();\n\n    assert(previousMove.type === _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PLAYED,\n           `Cannot challenge a ${previousMove.type}`);\n    assert(challenged.key === previousMove.playerKey,\n           \"Last player challenge mismatch\");\n\n    return this.getDictionary()\n    /* c8 ignore start */\n    .catch(\n      () => {\n        if (this._debug)\n          this._debug(\"No dictionary, so challenge always succeeds\");\n        return this.takeBack(challenger, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_WON);\n      })\n    /* c8 ignore stop */\n    .then(dict => {\n      const bad = previousMove.words\n            .filter(word => !dict.hasWord(word.word));\n\n      if (bad.length > 0) {\n        // Challenge succeeded\n        /* c8 ignore next 2 */\n        if (this._debug)\n          this._debug(\"Bad words: \", bad);\n\n        // Take back the challenged play. Irrespective of\n        // whether the challenger is the current player or\n        // not, takeBack should leave the next player\n        // after the challenged player with the turn.\n        return this.takeBack(challenger, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_WON);\n      }\n\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"Challenge failed,\", this.challengePenalty);\n\n      const currPlayerKey = this.getPlayer().key;\n      const nextPlayer = this.nextPlayer();\n\n      if (challenger.key === currPlayerKey &&\n          this.challengePenalty === _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Penalty.MISS) {\n\n        // Current player issued the challenge, they lose the\n        // rest of this turn\n\n        // Special case; if the challenged play would be the last\n        // play (challenged player has no more tiles) and\n        // challenging player is the next player, then it is game\n        // over. The bag is empty if there were no replacements, and\n        // the game is over if the challenged player has no tiles.\n        if ((!previousMove.replacements\n             || previousMove.replacements.length === 0)\n            && challenged.rack.isEmpty())\n          return this.confirmGameOver(\n            this.getPlayer(), _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.FAILED_CHALLENGE);\n        // Otherwise issue turn type=Game.Turns.CHALLENGE_LOST\n\n        // Penalty for a failed challenge is miss a turn,\n        // and the challenger is the current player, so their\n        // turn is at an end.\n        return this.finishTurn(challenged, {\n          type: _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_LOST,\n          penalty: _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Penalty.MISS,\n          challengerKey: challenger.key,\n          nextToGoKey: nextPlayer.key\n        })\n        .then(() => this.startTurn(nextPlayer));\n      }\n\n      // Otherwise it's either a points penalty, or the challenger\n      // was not the next player\n      let lostPoints = 0;\n      switch (this.challengePenalty) {\n      case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Penalty.MISS:\n        // tag them as missing their next turn\n        challenger.missNextTurn = true;\n        break;\n      case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Penalty.PER_TURN:\n        lostPoints = -this.penaltyPoints;\n        break;\n      case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Penalty.PER_WORD:\n        lostPoints = -this.penaltyPoints * previousMove.words.length;\n        break;\n      }\n\n      challenger.score += lostPoints;\n      return this.finishTurn(challenged, {\n        type: _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_LOST,\n        score: lostPoints,\n        challengerKey: challenger.key,\n        nextToGoKey: currPlayerKey\n      });\n      // no startTurn, because the challenge is asynchronous and\n      // shouldn't move the player on\n    });\n  }\n\n  /**\n   * Handler for swap command.\n   * Scrabble Rule 7: You may use a turn to exchange all,\n   * some, or none of the letters. To do this, place your\n   * discarded letter(s) facedown. Draw the same number of\n   * letters from the pool, then mix your discarded\n   * letter(s) into the pool.\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player player making the swap (must be current\n   * player)\n   * @param {Tile[]} tiles list of tiles to swap\n   * @return {Promise} resolving to the game\n   */\n  swap(player, tiles) {\n    assert(player.key === this.whosTurnKey,\n           `Not ${player.name}'s turn`);\n    assert(\n      this.letterBag.remainingTileCount() >= tiles.length,\n      `Cannot swap, bag only has ${this.letterBag.remainingTileCount()} tiles`);\n\n    // A swap counts as a pass. If the other player is also swapping\n    // or passing, that means two swaps at most.\n    player.passes++;\n\n    // Get the right number of new tiles from the bag\n    const replacements = this.letterBag.getRandomTiles(tiles.length);\n\n    // Return discarded tiles to the letter bag to make space\n    // on the player's rack\n    this.rackToBag(tiles, player);\n\n    // Place new tiles on the rack, now that there's space\n    for (const rep of replacements)\n      player.rack.addTile(rep);\n\n    const nextPlayer = this.nextPlayer();\n\n    return this.finishTurn(player, {\n      type: _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.SWAPPED,\n      nextToGoKey: nextPlayer.key,\n      placements: tiles, // the tiles that were swapped out\n      replacements: replacements // the tiles that are replacing them\n    })\n    .then(() => this.startTurn(nextPlayer));\n  }\n\n  /**\n   * Create another game the same, but with players re-ordered. The\n   * key for the new game is broadcast in a `NEXT_GAME` notification.\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @return {Promise} resolving to the new game\n   */\n  anotherGame() {\n    if (this.nextGameKey)\n      return Promise.reject(\"Next game already exists\");\n\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"Create game to follow\", this.key);\n    // Use this.constructor to get the class to pick up mixins.\n    const newGame = new (this.constructor)(this);\n    // Constructor will copy the old game key\n    newGame.key = (0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_0__.genKey)();\n    return newGame.create()\n    .then(() => newGame.onLoad(this._db))\n    .then(() => this.nextGameKey = newGame.key)\n    .then(() => this.save())\n    .then(() => {\n      newGame.creationTimestamp = Date.now();\n\n      // No turns inherited\n      newGame.turns = [];\n\n      // copy the players\n      const factory = this.constructor.CLASSES;\n      for (const p of this.players) {\n        const np = new factory.Player(p, factory);\n        newGame.addPlayer(np, true);\n      }\n\n      newGame.state = _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.WAITING;\n      // Players will be shuffled in playIfReady\n      newGame.whosTurnKey = undefined;\n\n      // for unit tests\n      newGame._noPlayerShuffle = this._noPlayerShuffle;\n\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"Created follow-on game\", newGame.key);\n    })\n    .then(() => newGame.save())\n    .then(() => newGame.playIfReady())\n    .then(() => this.notifyAll(_Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.NEXT_GAME, {\n      gameKey: newGame.key,\n      timestamp: Date.now()\n    }))\n    .then(() => newGame);\n  }\n\n  /**\n   * Toggle advice on/off. All players are told using\n   * a `MESSAGE` notification.\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player who is being toggled\n   */\n  toggleAdvice(player) {\n    player.toggleAdvice();\n    this.notifyPlayer(\n      player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE,\n      {\n        sender: /*i18n*/\"Advisor\",\n        text: (player.wantsAdvice\n               ? /*i18n*/\"Enabled\"\n               : /*i18n*/\"Disabled\")\n      });\n    if (player.wantsAdvice)\n      this.notifyAll(_Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE, {\n        sender: /*i18n*/\"Advisor\",\n        text: /*i18n*/\"advised\",\n        classes: \"warning\",\n        args: [ player.name ],\n        timestamp: Date.now()\n      });\n  }\n\n  /**\n   * Promise to advise player as to what better play they\n   * might have been able to make.\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player a Player\n   * @param {number} theirScore score they got from their play\n   * @return {Promise} resolves to undefined when the advice is ready.\n   */\n  advise(player, theirScore) {\n    if (!this.dictionary) {\n      this.notifyPlayer(\n        player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE,\n        {\n          sender: /*i18n*/\"Advisor\",\n          text: /*i18n*/\"No dictionary\"\n        });\n      return Promise.resolve();\n    }\n\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"Computing advice for\", player.name, \" > \", theirScore,\n                  player.rack.tiles().map(t => t.letter),\n                  this.board.stringify());\n\n    let bestPlay = null;\n    return this.findBestPlay(\n      player.rack.tiles(), data => {\n        if (typeof data === \"string\") {\n          /* c8 ignore next 2 */\n          if (this._debug)\n            this._debug(data);\n        } else\n          bestPlay = data;\n      }, this.dictionary)\n    .then(() => {\n      if (this._debug)\n        this._debug(\"Incoming\",bestPlay);\n      if (bestPlay && bestPlay.score > theirScore) {\n        this._debug(`Better play found for ${player.name}`);\n        const start = bestPlay.placements[0];\n        const words = bestPlay.words.map(w => w.word).join(\",\");\n        const advice = {\n          sender: /*i18n*/\"Advisor\",\n          text: /*i18n*/\"possible-score\",\n          args: [  words, start.row + 1, start.col + 1,\n                   bestPlay.score ]\n        };\n        this.notifyPlayer(player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE, advice);\n        this.notifyOthers(player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE, {\n          sender: /*i18n*/\"Advisor\",\n          text: /*i18n*/\"was-advised\",\n          classes: \"warning\",\n          args: [ player.name ],\n          timestamp: Date.now()\n        });\n      /* c8 ignore next 2 */\n      } else if (this._debug)\n        this._debug(\"No better plays found for\", player.name);\n    })\n    /* c8 ignore next */\n    .catch(e => console.error(\"Error\", e));\n  }\n\n  /**\n   * Handler for 'hint' request. This is NOT a turn handler.\n   * Asynchronously calculate a play for the given player, and\n   * notify all players that they requested a hint.\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player to get a hint for\n   */\n  hint(player) {\n    if (!this.dictionary) {\n      this.notifyPlayer(\n        player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE,\n        {\n          sender: /*i18n*/\"Advisor\",\n          text: /*i18n*/\"No dictionary\"\n        });\n      return;\n    }\n\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"Player\", player.name, \"asked for a hint\");\n\n    let bestPlay = null;\n    this.findBestPlay(\n      player.rack.tiles(), data => {\n        if (typeof data === \"string\") {\n          /* c8 ignore next 2 */\n          if (this._debug)\n            this._debug(data);\n        } else\n          bestPlay = data;\n      }, this.dictionary)\n    .then(() => {\n      const hint = {\n        sender: /*i18n*/\"Advisor\"\n      };\n      if (!bestPlay)\n        hint.text = /*i18n*/\"log-no-play\";\n      else {\n        const start = bestPlay.placements[0];\n        hint.text = /*i18n*/\"_hint_\";\n        const words = bestPlay.words.map(w => w.word).join(\",\");\n        hint.args = [\n          words, start.row + 1, start.col + 1, bestPlay.score\n        ];\n      }\n\n      // Tell the requesting player the hint\n      this.notifyPlayer(player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE, hint);\n\n      // Tell *everyone else* that they asked for a hint\n      this.notifyOthers(player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE, {\n        sender: /*i18n*/\"Advisor\",\n        text: /*i18n*/\"hinted\",\n        classes: \"warning\",\n        args: [ player.name ],\n        timestamp: Date.now()\n      });\n    })\n    /* c8 ignore start */\n    .catch(e => {\n      if (this._debug)\n        this._debug(\"Error:\", e);\n      this.notifyAll(_Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE, {\n        sender: /*i18n*/\"Advisor\",\n        text: e.toString(),\n        timestamp: Date.now()\n      });\n    });\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Add a word to the dictionary whitelist, asynchronously\n   * @function\n   * @instance\n   * @memberof game/Commands\n   * @param {Player} player player adding the word\n   * @param {string} word word to add\n   */\n  allow(player, word) {\n    word = word.toUpperCase();\n    this.getDictionary()\n    .then(dict => {\n      if (dict.addWord(word)) {\n        this.notifyAll(\n          _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE, {\n            sender: /*i18n*/\"Advisor\",\n              text:\n              /*i18n*/\"log-word-added\",\n              args: [\n                player.name, word, dict.name\n              ]\n            });\n        } else {\n          this.notifyPlayer(\n            player,\n            _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.MESSAGE, {\n              sender: /*i18n*/\"Advisor\",\n              text: /*i18n*/\"word-there\",\n              args: [ word, dict.name ]\n            });\n        }\n      });\n    }\n\n    /**\n     * Dispatcher for commands coming from the UI.\n     * @instance\n     * @memberof game/Commands\n     * @param {Game.Command} command the command\n     * @param {Player} player the player issuing the command\n     * @param {Object} args arguments to the command\n     */\n    dispatchCommand(command, player, args) {\n      /* c8 ignore next 3 */\n      if (this._debug)\n        this._debug(\"COMMAND\", command, \"player\", player.name,\n                    \"game\", this.key);\n\n      // c8 can ignore next because it's just routing\n      /* c8 ignore start */\n      switch (command) {\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.CHALLENGE:\n          return this.challenge(\n            player, this.getPlayerWithKey(args.challengedKey));\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.CONFIRM_GAME_OVER:\n        return this.confirmGameOver(player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.GAME_OVER);\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.PASS:\n          return this.pass(player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PASSED);\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.PAUSE:\n          return this.pause(player);\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.PLAY:\n          return this.play(player, args);\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.REDO:\n          return this.redo(args);\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.SWAP:\n          return this.swap(player, args);\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.TAKE_BACK:\n          return this.takeBack(player, _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.TOOK_BACK);\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.UNDO:\n          this.undo(this.popTurn());\n          break;\n\n        case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Command.UNPAUSE:\n          return this.unpause(player);\n\n        default:\n          return assert.fail(`unrecognized command: ${command}`);\n      }\n      /* c8 ignore stop */\n    }\n  };\n\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Commands.js?");

/***/ }),

/***/ "./src/game/Edition.js":
/*!*****************************!*\
  !*** ./src/game/Edition.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Edition\": () => (/* binding */ Edition)\n/* harmony export */ });\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/* global Platform */\n\n// Static DB of loaded Editions, indexed by name\nconst editions = {};\n\n/**\n * A Scrabble-like crossword game edition.\n *\n * Editions define the board layout and letter bag for a specific\n * Scrabble-like crossword game - Scrabble, Words With Friends, Lexulous,\n * or a game you've made yourself.\n *\n * Editions are only loaded once, and are subsequently kept in memory.\n * They are referred to by name in comms between the server and players,\n * and are not sent to the browser.\n */\nclass Edition {\n  /**\n   * Name of the edition\n   * @member {string}\n   */\n  name;\n\n  /**\n   * The initial bag of letters at\n   * the start of a game. Note that the ordering is unimportant\n   * but if a dictionary is used, then there has to be a 1:1\n   * correspondence between the alphabet used to generate the\n   * DAWG and the letters in the bag.\n   * @member {BagLetter[]}\n   */\n  bag;\n\n  /**\n   * A quarter-board, where each entry\n   * represents a row of the Lower-right quadrant of the\n   * board, so 0,0 is the middle. Each character in the strings\n   * represents the scoring for that square encoded as follows:\n   * d = double letter, D = double word\n   * t = triple letter, T = triple word\n   *  q = quad letter, Q = quad word\n   * _ = normal\n   * @member {string[]}\n   */\n  layout;\n\n  /**\n   * The number of tiles on a players rack\n   * @member {number}\n   */\n  rackCount;\n\n  /**\n   * Number of tiles swappable in a turn\n   * @member {number}\n   */\n  swapCount;\n\n  /**\n   * maximum number of players\n   * @member {number}\n   */\n  maxPlayers;\n\n  /**\n   * Map of bonuses, from number of tiles used in play to bonus\n   * number of points.\n   * @member {object.<number,number>}\n   */\n  bonuses;\n\n  /**\n   * Map from each letter in the bag to the score for that letter\n   * (computed)\n   * @member {object.<string,number>}\n   * @private\n   */\n  scores;\n\n  /**\n   * Number of rows on the board (computed)\n   * @member {string[]}\n   */\n  rows;\n\n  /**\n   * Number of columns on the board (computed)\n   * @member {string[]}\n   */\n  cols;\n\n  /**\n   * Sorted list of the unique non-blank letters in the bag (computed)\n   * @member {string[]}\n   */\n  alphabet;\n\n  /**\n   * @param {object} spec the specification for the edition. This is an\n   * object that contains all the non-computed fields of an edition.\n   */\n  constructor(spec) {\n    Object.getOwnPropertyNames(spec).forEach(\n      p => this[p] = spec[p]);\n    this.bonuses = spec.bonuses;\n\n    this.scores = { }; // map letter->score\n\n    this.rows = 2 * this.layout.length - 1;\n    this.cols = this.rows;\n\n    const alph = [];\n    for (let tile of this.bag) {\n      if (tile.letter)\n        alph.push(tile.letter);\n      else {\n        tile.letter = \" \"; // blank\n        tile.isBlank = true;\n      }\n      this.scores[tile.letter] = tile.score || 0;\n    }\n    this.alphabet = alph.sort();\n  }\n\n  /**\n   * Promise to load this edition\n   * @param {string} name what to call the edition\n   * @return {Promise} resolves to the Edition\n   */\n  static load(name) {\n    if (editions[name])\n      return Promise.resolve(editions[name]);\n\n    // Use requirejs to support dependencies in the edition\n    // files\n    return Platform.readFile(Platform.getFilePath(`editions/${name}.json`))\n    .then(spec => {\n      spec.name = name;\n      editions[name] = new Edition(spec);\n      //console.log(`Loaded edition ${name}`);\n      return editions[name];\n    });\n  }\n\n  /**\n   * Get the 'type' of a square on the board\n   * @param {number} col - 0-based column\n   * @param {number} row - 0-based row\n   * @return one of d = double letter, D = double word\n   * t = triple letter, T = triple word\n   * q = quad letter, Q = quad word\n   * _ = normal\n   */\n  squareType(col, row) {\n    const coli = Math.abs(col - Math.floor(this.cols / 2));\n    const rowi = Math.abs(row - Math.floor(this.rows / 2));\n    return this.layout[coli].charAt(rowi);\n  }\n\n  /**\n   * Get the score of a tile with the given letter\n   * @param {string} l letter to look up\n   * @return score of the letter, or 0 if not found\n   */\n  letterScore(l) {\n    return this.scores[l] ? this.scores[l] : 0;\n  }\n\n  /**\n   * Calculate any bonus afforded to plays of this length\n   * @param {number} tilesPaced number of tiles placed\n   * @return points bonus\n   */\n  calculateBonus(tilesPlaced) {\n    return this.bonuses ? (this.bonuses[tilesPlaced] || 0) : 0;\n  }\n}\n\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Edition.js?");

/***/ }),

/***/ "./src/game/Game.js":
/*!**************************!*\
  !*** ./src/game/Game.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _cdot_cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cdot/cbor */ \"./node_modules/@cdot/cbor/dist/mjs/index.js\");\n/* harmony import */ var _common_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Utils.js */ \"./src/common/Utils.js\");\n/* harmony import */ var _common_Fridge_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Fridge.js */ \"./src/common/Fridge.js\");\n/* harmony import */ var _loadDictionary_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadDictionary.js */ \"./src/game/loadDictionary.js\");\n/* harmony import */ var _Board_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Board.js */ \"./src/game/Board.js\");\n/* harmony import */ var _Edition_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Edition.js */ \"./src/game/Edition.js\");\n/* harmony import */ var _LetterBag_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LetterBag.js */ \"./src/game/LetterBag.js\");\n/* harmony import */ var _Move_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Move.js */ \"./src/game/Move.js\");\n/* harmony import */ var _Player_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Player.js */ \"./src/game/Player.js\");\n/* harmony import */ var _Rack_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Rack.js */ \"./src/game/Rack.js\");\n/* harmony import */ var _Square_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Square.js */ \"./src/game/Square.js\");\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Tile.js */ \"./src/game/Tile.js\");\n/* harmony import */ var _Turn_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Turn.js */ \"./src/game/Turn.js\");\n/*Copyright (C) 2019-2023\n The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/* global assert */\n/* global Platform */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Use the same CBOR tag handler for encoding and decoding, switching the\n// typeMap as required. This is Javascript, strictly synchronous.\nconst CBOR_tagHandler = new ((0,_cdot_cbor__WEBPACK_IMPORTED_MODULE_0__.KeyDictionaryHandler)(\n  (0,_cdot_cbor__WEBPACK_IMPORTED_MODULE_0__.IDREFHandler)((0,_cdot_cbor__WEBPACK_IMPORTED_MODULE_0__.TypeMapHandler)(_cdot_cbor__WEBPACK_IMPORTED_MODULE_0__.TagHandler))))({\n    added: k => { throw Error(k) },\n    keys: [\n      // Square\n      \"type\", \"surface\", \"col\", \"row\", \"tile\", \"underlay\",\n      \"letterScoreMultiplier\", \"wordScoreMultiplier\",\n      // Tile\n      \"letter\", \"score\", \"isBlank\", \"isLocked\",\n      // Surface\n      \"id\", \"cols\", \"rows\", \"squares\", \"midrow\", \"midcol\",\n      // LetterBag\n      \"tiles\", \"legalLetters\", \"isWild\", \"predictable\",\n      // Game\n      \"key\", \"state\", \"creationTimestamp\", \"players\", \"turns\", \"board\",\n      \"rackSize\", \"swapSize\", \"bonuses\", \"letterBag\", \"whosTurnKey\",\n      \"edition\", \"dictionary\", \"timerType\", \"timeAllowed\", \"timePenalty\",\n      \"challengePenalty\", \"penaltyPoints\",\n      \"wordCheck\", \"minPlayers\", \"maxPlayers\", \"predictScore\",\n      \"allowTakeBack\", \"allowUndo\", \"syncRacks\", \"nextGameKey\", \"pausedBy\",\n      // Bonus levels\n      \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n      // Player\n      \"name\", \"rack\", \"passes\", \"clock\", \"missNextTurn\", \"wantsAdvice\",\n      \"isRobot\", \"canChallenge\", \"delayBeforePlay\",\n      // Turn\n      \"gameKey\", \"playerKey\", \"nextToGoKey\", \"timestamp\",\n      \"placements\", \"replacements\", \"challengerKey\", \"endState\",\n      \"tilesRemaining\", \"time\",\n      // Move\n      \"words\", \"word\",\n      // findBestPlayController\n      \"game\", \"Platform\", \"data\",\n      // Replay\n      \"nextTurn\", \"predictable\",\n    ]\n  });\n\n/**\n * Class of Game objects. Contains most of the game logic.\n */\nclass Game {\n\n  /**\n   * Factory classes\n   * @private\n   */\n  static CLASSES = {\n    Square: _Square_js__WEBPACK_IMPORTED_MODULE_10__.Square,\n    Tile: _Tile_js__WEBPACK_IMPORTED_MODULE_11__.Tile,\n    Board: _Board_js__WEBPACK_IMPORTED_MODULE_4__.Board,\n    Game: Game,\n    LetterBag: _LetterBag_js__WEBPACK_IMPORTED_MODULE_6__.LetterBag,\n    Move: _Move_js__WEBPACK_IMPORTED_MODULE_7__.Move,\n    Player: _Player_js__WEBPACK_IMPORTED_MODULE_8__.Player,\n    Rack: _Rack_js__WEBPACK_IMPORTED_MODULE_9__.Rack,\n    Turn: _Turn_js__WEBPACK_IMPORTED_MODULE_12__.Turn\n  };\n\n  /**\n   * Game states.\n   * * `WAITING` - until enough players join the game\n   * * `PLAYING` - until the game is over, then one of:\n   * * `GAME_OVER` - game was played to end, or\n   * * `TWO_PASSES` - all players passed twice, or\n   * * `FAILED_CHALLENGE` - a challenge on the final play failed, or\n   * * `TIMED_OUT` - game is too old, will be pruned\n   * @typedef {WAITING|PLAYING|GAME_OVER|TWO_PASSES|FAILED_CHALLENGE|TIMED_OUT} Game.State\n   */\n  static State = {\n    WAITING:          \"Waiting for players\",\n    PLAYING:          \"Playing\",\n    FAILED_CHALLENGE: \"Challenge failed\",\n\n    GAME_OVER:        \"Game over\",\n    TWO_PASSES:       \"All players passed twice\",\n    TIMED_OUT:        \"Timed out\"\n  };\n\n  /**\n   * Commands that can be sent from the UI to the Backend.\n   * @typedef {UNPAUSE|PAUSE|CHALLENGE|PLAY|TAKE_BACK|PASS|GAME_OVER|SWAP} Game.Command\n   */\n  static Command = {\n    CHALLENGE:         \"challenge\",\n    CONFIRM_GAME_OVER: \"confirmGameOver\",\n    PASS:              \"pass\",\n    PAUSE:             \"pause\",\n    PLAY:              \"play\",\n    REDO:              \"redo\",\n    SWAP:              \"swap\",\n    TAKE_BACK:         \"takeBack\",\n    UNDO:              \"undo\",\n    UNPAUSE:           \"unpause\"\n  };\n\n  /**\n   * Indicate if we are to use worker threads for move computation or not\n   * (default true)\n   */\n  static USE_WORKERS = true;\n\n  /**\n   * Notifications sent between back and front end.\n   * * `CONNECTIONS`: list of the currently connected observers\n   * * `MESSAGE`: someone has sent a message\n   * * `NEXT_GAME`: a follow-on game is available\n   * * `PAUSE`: someone paused the game\n   * * `REJECT`: a move has been rejected (not found in dictionary)\n   * * `TICK`: the game timer has ticked\n   * * `TURN`: someone has made a move in the game\n   * * `UNDONE`: the last play was undone\n   * * `UNPAUSE`: someone has unpaused the game\n   * Notifications only sent to games pages by the server\n   * * `UPDATE`: a change has been made that requires a monitor update\n   * Notifications sent by a game page\n   * * `JOIN`: request to join (or observe) the game\n   * Notifications sent by games pages (monitors)\n   * * `MONITOR`: monitor wants to connect to the server\n   * @typedef {UNPAUSE|PAUSE|JOIN|REJECT|MESSAGE|NEXT_GAME|TICK|TURN|CONNECTIONS|UPDATE|MONITOR} Game.Notify\n   */\n  static Notify = {\n    ANOTHER_GAME: \"another game\",\n    CONNECTIONS:  \"connections\",\n    JOIN:         \"join game\",\n    MESSAGE:      \"message\",\n    NEXT_GAME:    \"next game\",\n    PAUSE:        \"pause game\",\n    REJECT:       \"reject play\",\n    TICK:         \"tick timer\",\n    TURN:         \"play turn\",\n    UNDONE:       \"undone\",\n    UNPAUSE:      \"unpause\",\n\n    /* Notifications sent to monitors (games pages) */\n    UPDATE:       \"update\",\n    MONITOR:      \"monitor\"\n  };\n\n  /**\n   * Different types of {@linkcode Turn}\n   * * PLAY - some tiles were placed on the board\n   * * SWAP - player swapped for fresh tiles from the bag\n   * * GAME_OVER - game is over\n   * * CHALLENGE_LOST - player challenged, and lost\n   * * CHALLENGE_WON - player challenged, and won\n   * * TOOK_BACK - player took back their play\n   * * PASSED - player passed\n   * * TIMED_OUT - player was timed out (if timer type is `TURN`)\n   * @typedef {PLAY|SWAP|GAME_OVER|CHALLENGE_LOST|CHALLENGE_WON|TOOK_BACK|PASSED|TIMED_OUT} Game.Turns\n   */\n  static Turns = {\n    PLAYED:         \"play\",\n    SWAPPED:        \"swap\",\n    GAME_ENDED:     \"game-over\",\n    CHALLENGE_LOST: \"challenge-lost\",\n    CHALLENGE_WON:  \"challenge-won\",\n    TOOK_BACK:      \"took-back\",\n    PASSED:         \"passed\",\n    TIMED_OUT:      \"timed-out\"\n  };\n\n  /**\n   * Types of game timer\n   * * `NONE` - game is untimed\n   * * `TURN` - each turn is time-limited\n   * * `GAME` - game is time limited, and a points penalty is applied\n   * for overtime\n   * @typedef {NONE|TURN|GAME} Game.Timer\n   */\n  static Timer = {\n    NONE:  undefined,\n    TURN:  /*i18n*/\"Turn timer\",\n    GAME:  /*i18n*/\"Game timer\"\n  };\n\n  /**\n   * Different types of penalty for a failed challenge.\n   * * `NONE` - no penalty\n   * * `MISS` - challenging player misses next turn\n   * * `PER_TURN` - challenger loses a fixed number of points\n   * * `PER_WORD` - challenger loses points for each wrongly challenged word\n   * @typedef {NONE|MISS|PER_TURN|PER_WORD} Game.Penalty\n   */\n  static Penalty = {\n    NONE:     undefined,\n    MISS:     /*i18n*/\"Miss next turn\",\n    PER_TURN: /*i18n*/\"Lose points\",\n    PER_WORD: /*i18n*/\"Lose points per word\"\n  };\n\n  /**\n   * Ways to check played words.\n   * * NONE - don't check played words\n   * * AFTER - report to player (only) if played words were in dictionary\n   * * REJECT - refuse to accept words not in the dictionary. A bad play\n   *   in this case does not result in a penalty, it just won't accept\n   *   the play.\n   * @typedef {NONE|AFTER|REJECT} Game.WordCheck\n   */\n  static WordCheck = {\n    NONE:    undefined,\n    AFTER:   /*i18n*/\"Check words after play\",\n    REJECT:  /*i18n*/\"Reject unknown words\"\n  };\n\n  /**\n   * Defaults. CAREFUL! These defaults are not automatically applied\n   * in the constructor; if a field isn't set in the object passed to\n   * the constructor, the default will not be automatically applied\n   * (except for edition, which is always required). So if you want\n   * to change any of the defaults, you need to make sure the\n   * constructor code will pick the new value up.\n   */\n  static DEFAULTS = {\n\t  edition:         \"English_Scrabble\",\n\t  dictionary:      \"CSW2019_English\",\n\n    timerType:        Game.Timer.NONE,\n\t\ttimeAllowed:      25, // minutes per game\n\t\ttimePenalty:      0,\n\n    challengePenalty: Game.Penalty.NONE,\n\t\tpenaltyPoints:    5,\n\n    wordCheck:        Game.WordCheck.NONE,\n    predictScore:     true,\n    minPlayers:       2,\n    maxPlayers:       0,\n    allowUndo:        false,\n    allowTakeBack:    true\n  };\n\n  /**\n   * Channels connecting to front ends\n   * @member {Channel[]}\n   * @private\n   */\n  _channels = [];\n\n  // WARNING! Do NOT use the ESM field syntax for the fields that are\n  // serialised. If we do that, then the constructor blows the field\n  // away when loading using CBOR. :-(\n\n  /**\n   * @param {object} params Parameter object. This can be another Game\n   * to copy game parameters, or a generic object with fields the same\n   * names as Game.DEFAULTS fields. Note that only fields in\n   * `Game.DEFAULTS` are used, other fields are ignored.\n   *\n   * Note that if a field in `Game.DEFAULTS` is not defined in\n   * `params`, then the value from `Game.DEFAULTS` will *not* be\n   * applied (except for `edition`). A field missing from `params` is\n   * treated as `undefined`, and `undefined` means `undefined`, and\n   * *not* \"apply the default\".\n   */\n  constructor(params) {\n\n    /**\n     * Debug function.\n     * @member {function}\n     * @private\n     */\n    this._debug = params._debug;\n\n    /**\n     * Key that uniquely identifies this game.\n     * @member {Key}\n     */\n    this.key = params.key || (0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_1__.genKey)();\n\n    /**\n     * An i18n message identifier indicating the game state.\n     * @member {State}\n     */\n    this.state = Game.State.WAITING;\n\n    /**\n     * Epoch ms when this game was created.\n     * @member {number}\n     */\n    this.creationTimestamp = params.creationTimestamp || Date.now();\n\n    /**\n     * List of players in the game.\n     * Lateinit as the result of a load.\n     * @member {Player[]}\n     * @private\n     */\n    this.players = [];\n\n    /**\n     * Complete list of the turn history of this game.\n     * @member {Turn[]}\n     * @private\n     */\n    this.turns = [];\n\n    /**\n     * The game board.\n     * @member {Board}\n     */\n    this.board = undefined;\n\n    /**\n     * Size of rack. Always the same as Edition.rackCount,\n     * because we don't hold a pointer to the Edition. Note this\n     * is saved with the game.\n     * Copied from the {@linkcode Edition} in {@linkcode Game#create|create}.\n     * @member {number}\n     */\n    this.rackSize = undefined;\n\n    /**\n     * Size of swap rack.\n     * Lateinit in {@linkcode Game#create|create} or as the result of a\n     * load.\n     * @member {number}\n     */\n    this.swapSize = undefined;\n\n    /**\n     * Map of number of tiles played, to bonus for the play.\n     * Lateinit in {@linkcode Game#create|create} or as the result of a\n     * load.\n     * @member {object<number,number>}\n     * @private\n     */\n    this.bonuses = undefined;\n\n    /**\n     * Bag of remaining letters, initialised from the edition.\n     * Lateinit in {@linkcode Game#create|create} or as the result of a\n     * load.\n     * @member {LetterBag}\n     */\n    this.letterBag = undefined;\n\n    /**\n     * Key of next player to play in this game.\n     * @member {string?}\n     */\n    this.whosTurnKey = undefined;\n\n    /**\n     * Undo engine for this game. Lazy init when required.\n     * @member {Undo?}\n     * @private\n     */\n    this._undoer = undefined;\n\n    /**\n     * Name of the edition (see {@linkcode Edition}).\n     * Edition objects are stored in the Edition class and\n     * demand-loaded as required. This allows us to\n     * throw Game objects around without worrying too much about\n     * the data volume.\n     * @member {string}\n     */\n    this.edition = params.edition || Game.DEFAULTS.edition;\n\n    /*\n     * When you name a field in a class declaration without an\n     * initial value, it gets initialised to undefined. This means the\n     * object gets cluttered with undefined fields that are not used\n     * in the configuration. So we test whether these optional fields\n     * are required or not.\n     */\n\n    if (params.dictionary)\n      /**\n       * Name of the dictionary used for checking words and\n       * generating robot plays. A game doesn't need to have a\n       * dictionary if words are not checked and there is no robot\n       * player.\n       * This is just the name of the dictionary. Dictionary objects\n       * are stored in the {@linkcode Dictionary} class and\n       * demand-loaded as and when required. This allows us to\n       * throw Game objects around without worrying too much about\n       * the data volume.\n       * @member {string?}\n       */\n      this.dictionary = params.dictionary;\n\n    if (params.timerType && !/^none$/i.test(params.timerType)) {\n      /**\n       * Type of timer for this game.\n       * @member {Timer?}\n       */\n      this.timerType = params.timerType;\n    }\n\n    if (this.timerType) {\n      if (typeof params.timeAllowed !== \"undefined\") {\n        /**\n         * Time limit for this game, in minutes. If `timerType` is\n         * `Timer.GAME` defaults to 25 minutes, and 1 minute for\n         * `Timer.TURN`.\n         * @member {number?}\n         */\n        this.timeAllowed = params.timeAllowed || 0;\n      }\n      else if (this.timerType === Game.Timer.GAME)\n        this.timeAllowed = Game.DEFAULTS.timeAllowed;\n      else\n        this.timeAllowed = 1;\n\n      if (this.timerType === Game.Timer.GAME) {\n        /**\n         * Time penalty for this game, points lost per minute over\n         * timeAllowed. Only used if `timerType` is `TIMER_GAME`.\n         * @member {number?}\n         */\n        this.timePenalty = params.timePenalty || Game.DEFAULTS.timePenalty;\n      }\n    }\n\n    /**\n     * The type of penalty to apply for a failed challenge.\n     * @member {Penalty}\n     */\n    if (params.challengePenalty && params.challengePenalty !== \"none\")\n      this.challengePenalty = params.challengePenalty;\n\n    if (this.challengePenalty === Game.Penalty.PER_TURN\n        || this.challengePenalty === Game.Penalty.PER_WORD) {\n      /**\n       * The score penalty to apply for a failed challenge. Only used\n       * if `challengePenalty` is `Game.Penalty.PER_TURN` or `Game.Penalty.PER_WORD`.\n       * @member {number?}\n       */\n      this.penaltyPoints = params.penaltyPoints || Game.DEFAULTS.penaltyPoints;\n    }\n\n    if (params.wordCheck && params.wordCheck !== \"none\") {\n      /**\n       * Whether or not to check plays against the dictionary.\n       * @member {WordCheck?}\n       */\n      this.wordCheck = params.wordCheck;\n    }\n\n    if (params.minPlayers > 2) {\n      /**\n       * Least number of players must have joined before this game\n       * can start. Must be at least 2.\n       * @member {number?}\n       */\n      this.minPlayers = params.minPlayers;\n    }\n\n    if (params.maxPlayers >= 2) {\n      /**\n       * Most number of players who can join this game. < 2\n       * means no limit.\n       * @member {number?}\n       */\n      this.maxPlayers = params.maxPlayers;\n    }\n\n    if (typeof this.maxPlayers !== \"undefined\"\n        && this.maxPlayers < (this.minPlayers || 2))\n      delete this.maxPlayers; // infinity\n\n    if (params.predictScore) {\n      /**\n       * Whether or not to show the predicted score from tiles\n       * placed during the game. This should be false in tournament\n       * play, true otherwise.\n       * @member {?boolean}\n       */\n      this.predictScore = true;\n    }\n\n    if (params.allowTakeBack) {\n      /**\n       * Whether or not to allow players to take back their most recent\n       * move without penalty, so long as the next player hasn't\n       * challenged or played.\n       * @member {boolean?}\n       */\n      this.allowTakeBack = true;\n    }\n\n    if (params.allowUndo) {\n      /**\n       * Whether or not to allow players to undo previous\n       * moves without penalty. Implies syncRacks.\n       * @member {boolean?}\n       */\n      this.allowUndo = true;\n    }\n\n    if (params.syncRacks) {\n      /**\n       * Disables obfustication of move data, so any player\n       * could potentially reverse-engineer\n       * the entire board and all racks if this is enabled.\n       * @member {boolean?}\n       */\n      this.syncRacks = true;\n    }\n\n    if (params._noPlayerShuffle) {\n      /**\n       * Internal, for debug only.\n       * @member {boolean?}\n       * @private\n       */\n      this._noPlayerShuffle = true;\n    }\n\n    if (params.nextGameKey) {\n      /**\n       * When a game is ended, nextGameKey is the key for the\n       * continuation game.\n       * @member {string?}\n       */\n      this.nextGameKey = params.nextGameKey;\n    }\n\n    if (params.pausedBy) {\n      /**\n       * Name (NOT key) of the player who paused the game (if it's paused).\n       * @member {string?}\n       */\n      this.pausedBy = params.pausedBy;\n    }\n  }\n\n  /**\n   * Creation steps that can't be done in the constructor because\n   * they require promises.\n   * Load the edition and create the board and letter bag.\n   * Not done in the constructor because we need to return\n   * a Promise. Must be followed by onLoad to connect a\n   * DB and complete initialisation of private fields.\n   * @return {Promise} that resolves to this\n   */\n  create() {\n    return this.getEdition()\n    .then(edo => {\n      const factory = this.constructor.CLASSES;\n      this.board = new factory.Board(factory, edo);\n      this.letterBag = new _LetterBag_js__WEBPACK_IMPORTED_MODULE_6__.LetterBag(edo);\n      this.bonuses = edo.bonuses;\n      this.rackSize = edo.rackCount;\n      this.swapSize = edo.swapCount;\n      return this;\n    });\n  }\n\n  /**\n   * Get the edition for this game, lazy-loading as necessary\n   * @return {Promise} resolving to an {@linkcode Edition}\n   */\n  getEdition() {\n    return _Edition_js__WEBPACK_IMPORTED_MODULE_5__.Edition.load(this.edition);\n  }\n\n  /**\n   * Add a player to the game.\n   * @param {Player} player\n   * @param {boolean?} fillRack true to fill the player's rack\n   * from the game's letter bag.\n   * @return {Game} this\n   */\n  addPlayer(player, fillRack) {\n    assert(this.letterBag, \"Cannot addPlayer() before create()\");\n    assert(\n      !this.maxPlayers || this.players.length < this.maxPlayers,\n      \"Cannot addPlayer() to a full game\");\n    player._debug = this._debug;\n    this.players.push(player);\n    if (this.timerType)\n      player.clock = this.timeAllowed * 60;\n    if (fillRack)\n      player.fillRack(this.letterBag, this.rackSize);\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(this.key, \"added player\", player.stringify());\n    return this;\n  }\n\n  /**\n   * Remove a player from the game, taking their tiles back into\n   * the bag\n   * @param {Player} player\n   */\n  removePlayer(player) {\n    player.returnTiles(this.letterBag);\n    const index = this.players.findIndex(p => p.key === player.key);\n    assert(index >= 0,\n           `No such player ${player.key} in ${this.key}`);\n    this.players.splice(index, 1);\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(player.key, \"left\", this.key);\n    if (this.players.length < (this.minPlayers || 2)\n        && this.state !== Game.State.GAME_OVER)\n      this.state = Game.State.WAITING;\n  }\n\n  /**\n   * Get the player with key\n   * @param {string} player key\n   * @return {Player} player, or undefined if not found\n   */\n  getPlayerWithKey(key) {\n    return this.players.find(p => p.key === key);\n  }\n\n  /**\n   * Get the current player.\n   * @return {Player} player, or undefined if not found\n   */\n  getPlayer() {\n    return this.getPlayerWithKey(this.whosTurnKey);\n  }\n\n  /**\n   * Get a list of all players in the game\n   * @return {Player[]} list of players\n   */\n  getPlayers() {\n    return this.players;\n  }\n\n  /**\n   * Get the last player before the given player, identified by key\n   * @param {string|Player} player the current player if undefined, or\n   * the player to get the previous player of\n   * @return {Player} previous player\n   */\n  previousPlayer(player) {\n    if (typeof player === \"undefined\")\n      player = this.getPlayer();\n    else if (typeof player === \"string\")\n      player = this.getPlayerWithKey(player);\n    const index = this.players.findIndex(p => p.key === player.key);\n    assert(index >= 0, `${player.key} not found in ${this.key}`);\n    return this.players[\n      (index + this.players.length - 1) % this.players.length];\n  }\n\n  /**\n   * Get the next player to play. A player might be skipped if they\n   * are marked as missing a turn.\n   * @param {string|Player} player the current player if undefined,\n   * or the key of a player, or the player\n   * of the player to get the next player to\n   * @return {Player} the next player\n   */\n  nextPlayer(player) {\n    if (typeof player === \"undefined\")\n      player = this.getPlayer();\n    else if (typeof player === \"string\")\n      player = this.getPlayerWithKey(player);\n    let index = this.players.findIndex(p => p.key === player.key);\n    assert(index >= 0, `${player.key} not found in ${this.key}`);\n    for (let i = 0; i < this.players.length; i++) {\n      let nextPlayer = this.players[(index + 1) % this.players.length];\n      if (nextPlayer.missNextTurn) {\n        nextPlayer.missNextTurn = false;\n        index++;\n      } else\n        return nextPlayer;\n    }\n    /* c8 ignore next */\n    return assert.fail(\n      `Unable to determine next player after ${player.key}`);\n  }\n\n  /**\n   * Calculate any bonus afforded to plays of this length\n   * @param {number} tilesPaced number of tiles placed\n   * @return points bonus\n   */\n  calculateBonus(tilesPlaced) {\n    // Duplicates Edition.calculateBonus, so it can be used even if\n    // the Edition is not loaded (e.g. on the client side)\n    return this.bonuses ? (this.bonuses[tilesPlaced] || 0) : 0;\n  }\n\n  /**\n   * Get the current winning score\n   * @return {number} points\n   */\n  winningScore() {\n    return this.players.reduce(\n      (max, player) => Math.max(max, player.score), 0);\n  }\n\n  /**\n   * Get the current winning player\n   * @return {Player} player in the lead\n   */\n  getWinner() {\n    return this.players.reduce(\n      (best, player) => (player.score > best.score ? player : best),\n      this.players[0]);\n  }\n\n  /**\n   * If there is a player with no tiles, return them.\n   * @return {Player} the player with no tiles, or undefined\n   */\n  getPlayerWithNoTiles() {\n    return this.players.find(\n      player => (player.rack.tiles().length === 0));\n  }\n\n  /**\n   * Return true if the game state indicates the game has ended\n   */\n  hasEnded() {\n    switch (this.state) {\n    case Game.State.WAITING:\n    case Game.State.FAILED_CHALLENGE:\n    case Game.State.PLAYING:\n      return false;\n    case undefined:\n    case Game.State.GAME_OVER:\n    case Game.State.TWO_PASSES:\n    case Game.State.TIMED_OUT:\n      return true;\n    default:\n      assert.fail(`Bad game state ${this.state}`);\n      return true;\n    }\n  }\n\n  /**\n   * Determine when the last activity on the game happened. This\n   * is either the last time a turn was processed, or the creation time.\n   * @return {number} a time in epoch ms\n   */\n  lastActivity() {\n    const last = this.lastTurn();\n    if (last)\n      return last.timestamp;\n\n    return this.creationTimestamp;\n  }\n\n  /**\n   * Get the last turn made in this game.\n   * @return {Turn} the last turn recorded for the game, or undefined\n   * if no turns have been made yet.\n   */\n  lastTurn() {\n    if (this.turns.length === 0)\n      return undefined;\n\n    return this.turns[this.turns.length - 1];\n  }\n\n  /**\n   * Add a turn to the game\n   * @param {Turn} the turn to add\n   */\n  pushTurn(turn) {\n    return this.turns.push(turn);\n  }\n\n  /**\n   * Remove and return the last turn in the game\n   * @return {Turn} the turn popped\n   */\n  popTurn() {\n    assert(this.turns.length > 0, \"No turns\");\n    return this.turns.pop();\n  }\n\n  /**\n   * Iterate over turns calling cb on each, flagging when the\n   * last (most recent) turn is reached.\n   * @param {function} cb (turn, isLastTurn)\n   */\n  forEachTurn(cb) {\n    this.turns.forEach(\n      (turn, i) => cb(turn, i === this.turns.length - 1));\n  }\n\n  /* c8 ignore start */\n\n  /**\n   * Get the board square at [col][row]\n   * @return {Square} at col,row\n   */\n  at(col, row) {\n    // Only used client-side\n    return this.board.at(col, row);\n  }\n\n  /**\n   * Debug\n   */\n  stringify() {\n    const options = [ `edition:${this.edition}` ];\n    if (this.dictionary)\n      options.push(`dictionary:${this.dictionary}`);\n    if (this.timerType) {\n      options.push(`${this.timerType}:${this.timeAllowed}`);\n      if (this.timerType === Game.Timer.GAME)\n        options.push(`timePenalty:${this.timePenalty}`);\n    }\n    if (this.challengePenalty) {\n      options.push(this.challengePenalty);\n      if (this.challengePenalty === Game.Penalty.PER_TURN\n          || this.challengePenalty === Game.Penalty.PER_WORD)\n        options.push(`lose:${this.penaltyPoints}`);\n    }\n    if (this.whosTurnKey)\n      options.push(`next:${this.whosTurnKey}`);\n\n    if (this.wordCheck) options.push(this.wordCheck);\n    if (this.challengePenalty) options.push(this.challengePenalty);\n    if (this.predictScore) options.push(\"Predict\");\n    if (this.allowTakeBack) options.push(\"Allow takeback\");\n    if (this.minPlayers)\n      options.push(`>=${this.minPlayers}`);\n    const ps = this.players.map(p => p.stringify()).join(\",\");\n    options.push(`players:[${ps}]`);\n    if (this.maxPlayers)\n      options.push(`<=${this.maxPlayers}`);\n    if (this.nextGameKey)\n      options.push(`Next game ${this.nextGameKey}`);\n    if (this.pausedBy)\n      options.push(`Paused by ${this.pausedBy}`);\n    return `Game ${this.key} {${options.join(\", \")}}`;\n  }\n\n  /* c8 ignore stop */\n\n  /**\n   * Determine if any players are robots.\n   * @return the first robot found.\n   */\n  hasRobot() {\n    return this.players.find(p => p.isRobot);\n  }\n\n  /**\n   * Create a simple structure describing a subset of the game state,\n   * for sending to the 'games' interface.  The structure does not\n   * suffice to fully reconstruct the game; there will be no `board`,\n   * `rackSize`, `swapSize`, `bonuses`, `turns` will be a list of\n   * {@linkcode Turn#serialisable|Turn.serialisable}, and `players`\n   * will be a list of {@linkcode Player#serialisable|Player.serialisable}.\n   * @param {UserManager} um user manager object for getting emails; only\n   * works on server side\n   * @return {Promise} resolving to a simple object with\n   * key game data\n   */\n  serialisable(um) {\n    return Promise.all(\n      this.players.map(player => player.serialisable(this, um)))\n    .then(ps => {\n      const simple = {\n        key: this.key,\n        creationTimestamp: this.creationTimestamp,\n        edition: this.edition,\n        dictionary: this.dictionary,\n        state: this.state,\n        allowUndo: this.allowUndo,\n        // players is a list of Player.serialisable\n        players: ps,\n        whosTurnKey: this.whosTurnKey,\n        timerType: this.timerType,\n        challengePenalty: this.challengePenalty,\n        lastActivity: this.lastActivity(), // epoch ms\n        // this.board is not sent\n        // this.rackSize not sent\n        // this.swapSize not sent\n        // this.bonuses not sent\n        // turns is a list of Turn.serialisable\n        turns: this.turns.map(t => t.serialisable())\n      };\n      if (this.minPlayers) simple.minPlayers = this.minPlayers;\n      if (this.maxPlayers) simple.maxPlayers = this.maxPlayers;\n      if (this.wordCheck) simple.wordCheck = this.wordCheck;\n      if (this.timerType != Game.TIMER_NONE) {\n        simple.timeAllowed = this.timeAllowed;\n        simple.timePenalty = this.timePenalty;\n      }\n      if (this.challengePenalty === Game.Penalty.PER_TURN\n          || this.challengePenalty === Game.Penalty.PER_WORD)\n        simple.penaltyPoints = this.penaltyPoints;\n      if (this.nextGameKey) simple.nextGameKey = this.nextGameKey;\n      if (this.pausedBy) simple.pausedBy = this.pausedBy;\n      if (this.predictScore) simple.predictScore = true;\n      if (this.allowTakeBack) simple.allowTakeBack = true;\n\n      return simple;\n    });\n  }\n\n  /**\n   * Promise to finish the construction or load from serialisation\n   * of a game.\n   * A game has to know what DB so it knows where to save. The\n   * database and connections are not serialised, and must be\n   * reset when loading.\n   * @param {Database} db the db to use to store games\n   * @return {Promise} Promise that resolves to the game\n   */\n  onLoad(db) {\n    // if this onLoad follows a load from serialisation, which\n    // does not invoke the constructor.\n    // We always set the _db\n\n    /**\n     * Database containing this game. Only available server-side,\n     * and not serialised.\n     * @member {Database}\n     * @private\n     */\n    this._db = db;\n\n    if (!this._channels)\n      this._channels = [];\n\n    // Compatibility; timeLimit in s to timeAllowed in minutes\n    if (this.timeLimit && !this.timeAllowed)\n      this.timeAllowed = this.timeLimit / 60;\n\n    if (!this._debug)\n      this._debug = () => {};\n    if (!this.players)\n      this.players = [];\n    this.players.forEach(p => p._debug = this._debug);\n    if (!this.turns)\n      this.turns = [];\n\n    return Promise.resolve(this);\n  }\n\n  /**\n   * Load a game from a structure generated by serialisable. This\n   * method is designed to use to support rapid loading of games\n   * into the `games` browser interface. The game will be incomplete,\n   * only the fields supported by serialisable will be populated.\n   * @param {object} factory Game class to be used as factory\n   * @param {object} simple object generated by serialisable()\n   */\n  static fromSerialisable(simple, factory) {\n    const game = new factory.Game(simple);\n    game.state = simple.state;\n    game.players = simple.players.map(\n      p => factory.Player.fromSerialisable(p, factory));\n    game.turns = simple.turns.map(t => _Turn_js__WEBPACK_IMPORTED_MODULE_12__.Turn.fromSerialisable(t, factory));\n    return game;\n  }\n\n  // Shortcuts for moving tiles around within the game\n\n  /**\n   * Shorthand to remove tiles from the board and put\n   * them on a rack\n   * @param {Tile[]} tiles list of tile placements\n   * @param {Player} player player whose rack we are adjusting\n   */\n  boardToRack(tiles, player) {\n    for (const placement of tiles) {\n      const square = this.at(placement.col, placement.row);\n      const tile = square.unplaceTile();\n      assert(tile, `No tile at ${(0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(placement)}`);\n      player.rack.addTile(tile);\n    }\n  }\n\n  /**\n   * Shorthand to move tiles from the rack to the board\n   * at the locations dictated in a set of placements\n   * @param {Tile[]} tiles list of tile placements\n   * @param {Player} player player whose rack we are adjusting\n   * @param {function?} cb optional callback on each tile that was placed\n   */\n  rackToBoard(tiles, player, cb) {\n    for (const place of tiles) {\n      const tile = player.rack.removeTile(place);\n      assert(\n        tile, `Tile ${(0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(place)} not found on rack`);\n      const square = this.at(place.col, place.row);\n      square.placeTile(tile, true);\n      if (cb)\n        cb(tile);\n    }\n  }\n\n  /**\n   * Shorthand method to take tiles out of the letter bag and put\n   * them on a rack\n   * @param {Tile[]} tiles list of tiles\n   * @param {Player} player player whose rack we are adjusting\n   */\n  bagToRack(tiles, player) {\n    for (const tile of tiles) {\n      const removed = this.letterBag.removeTile(tile);\n      assert(removed, `${(0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(tile)} missing from bag`);\n      player.rack.addTile(removed);\n    }\n  }\n\n  /**\n   * Shorthand method to move a set of tiles from a rack to the bag\n   * @param {Tile[]} tiles list of tiles\n   * @param {Player} player player whose rack we are adjusting\n   */\n  rackToBag(tiles, player) {\n    for (const tile of tiles) {\n      const removed = player.rack.removeTile(tile);\n      assert(removed, `${(0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(tile)} missing from rack`);\n      this.letterBag.returnTile(removed);\n    }\n  }\n\n  /**\n   * Start, or continue, playing the game if preconditions are met.\n   * @return {Promise} promise that resolves to the game\n   */\n  playIfReady() {\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"playIfReady \", this.key,\n                  this.whosTurnKey ? `player ${this.whosTurnKey}` : \"\",\n                  \"state\", this.state);\n\n    if (this.hasEnded()) {\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\tgame is over\");\n      return Promise.resolve(this);\n    }\n\n    // Check preconditions for starting the game\n    if (this.players.length < (this.minPlayers || 2)) {\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\tnot enough players\");\n      // Result is not used\n      return Promise.resolve(this);\n    }\n\n    // If no turn has been allocated yet,\n    // shuffle the players, and pick a random tile from the bag.\n    // The shuffle can be suppressed for unit testing.\n    if (this.state === Game.State.WAITING) {\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\tpreconditions met\");\n\n      if (this.players.length > 1 && !this._noPlayerShuffle) {\n        /* c8 ignore next 2 */\n        if (this._debug)\n          this._debug(\"\\tshuffling player order\");\n        for (let i = this.players.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          // i = 1, j = 0,1\n          //    j = 0, swap 0 and 1\n          //    j = 1, leave 1 in place\n          const temp = this.players[i];\n          this.players[i] = this.players[j];\n          this.players[j] = temp;\n        }\n        // Notify all connections of the order change\n        // (asynchronously)\n        this.sendCONNECTIONS();\n      }\n\n      const player = this.players[0];\n      this.whosTurnKey = player.key; // assign before save()\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\t\", player.key, \"to play\");\n      this.state = Game.State.PLAYING;\n\n      return this.save()\n      // startTurn will autoplay if the first player is\n      // a robot. It will also start the clock.\n      .then(() => this.startTurn(player));\n    }\n\n    const nextPlayer = this.getPlayer();\n    if (nextPlayer) {\n      if (nextPlayer.isRobot)\n        return this.startTurn(nextPlayer);\n\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\twaiting for\", nextPlayer.name, \"to play\");\n      this.startTheClock();\n    }\n    return Promise.resolve(this);\n  }\n\n  /**\n   * TODO: move to BackendGame\n   * Wrap up after a command handler that is returning a Turn.\n   * Log the command, determine whether the game has ended,\n   * save state and notify connected players with the Turn object.\n   * @param {Player} player player who's turn it was\n   * @param {object} turn fields to populate the Turn to finish\n   * @return {Promise} that resolves to the game\n   */\n  finishTurn(player, turn) {\n    turn = new _Turn_js__WEBPACK_IMPORTED_MODULE_12__.Turn(turn);\n    turn.gameKey = this.key;\n    turn.playerKey = player.key;\n\n    // store turn (server side)\n    this.pushTurn(turn);\n\n    let redacted = turn;\n\n    // Censor replacements for all but the player who's play it was\n    if (!this.allowUndo && !this.syncRacks && turn.replacements) {\n      redacted = new _Turn_js__WEBPACK_IMPORTED_MODULE_12__.Turn(turn);\n      redacted.replacements = [];\n      for (const tile of turn.replacements) {\n        const rt = new _Tile_js__WEBPACK_IMPORTED_MODULE_11__.Tile(tile);\n        rt.letter = '#';\n        redacted.replacements.push(rt);\n      }\n    }\n\n    return this.save()\n    .then(() => Promise.all([\n      this.notifyPlayer(player, Game.Notify.TURN, turn),\n      this.notifyOthers(player, Game.Notify.TURN, redacted)\n    ]))\n    .then(() => this);\n  }\n\n  /**\n   * If the game has a time limit, start an interval timer.\n   * @return {boolean} true if the clock is started, false otherwise\n   * (e.g. if it is already running)\n   * @private\n   */\n  startTheClock() {\n    if (typeof this._intervalTimer === \"undefined\"\n        && this.timerType\n        && this.state === Game.State.PLAYING) {\n\n      // Broadcast a ping every second\n      /**\n       * Timer object for ticking.\n       * @member {object?}\n       * @private\n       */\n      this._intervalTimer = setInterval(() => this.tick(), 1000);\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(this.key, \"started the clock\");\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Stop the interval timer, if there is one\n   * @return {boolean} true if the clock is stopped, false otherwise\n   * @private\n   */\n  stopTheClock() {\n    if (typeof this._intervalTimer == \"undefined\")\n      return false;\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(this.key, \"stopped the clock\");\n    clearInterval(this._intervalTimer);\n    delete(this._intervalTimer);\n    return true;\n  }\n\n  /**\n   * Tell all clients a tick has happened (or\n   * remind them of the current number of seconds to play)\n   * @private\n   */\n  tick() {\n    const player = this.getPlayer();\n    if (!player)\n      return;\n\n    player.tick();\n\n    // Really should save(), otherwise the ticks won't\n    // survive a server restart. However it's expensive, and server\n    // restarts are rare, so let's not.\n    this.notifyAll(\n      Game.Notify.TICK,\n      {\n        gameKey: this.key,\n        playerKey: player.key,\n        clock: player.clock,\n        timestamp: Date.now()\n      });\n  }\n\n  /**\n   * Start (or restart) the turn of the given player.\n   * @param {Player?} player the the player to get the turn.\n   * @param {number?} timeout Only relevant when `timerType` is\n   * `Game.Timer.TURN`. Turn timeout for this turn. Set if\n   * this is a restart of an unfinished turn, defaults to\n   * this.timeAllowed if undefined.\n   * @return {Promise} a promise that resolves to undefined\n   * @private\n   */\n  startTurn(player, timeout) {\n    assert(player, \"No player\");\n\n    if (!this.players.find(p => p.passes < 2))\n      return this.confirmGameOver(player, Game.State.TWO_PASSES);\n\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"startTurn\", player.name, player.key);\n\n    this.whosTurnKey = player.key;\n\n    if (player.isRobot) {\n      // May recurse if the player after is also a robot, but\n      // the recursion will always stop when a human player\n      // is reached, so never deep.\n      return this.autoplay();\n    }\n\n    // For a timed game, make sure the clock is running and\n    // start the player's timer.\n\n    if (this.timerType) {\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\ttimed game,\", player.name,\n                    \"has\", (timeout || this.timeAllowed),\n                    \"left to play\",this.timerType);\n      this.startTheClock(); // does nothing if already started\n    }\n    else {\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\tuntimed game, wait for\", player.name, \"to play\");\n      return Promise.resolve(this);\n    }\n\n    if (this.timerType === Game.Timer.TURN)\n      // Make the player pass when their clock reaches 0\n      player.setTimeout(\n        timeout || this.timeAllowed * 60,\n        () => this.pass(player, Game.Turns.TIMED_OUT));\n\n    return Promise.resolve(this);\n  }\n\n  /**\n   * Robot play for the current player. This may result in a challenge.\n   * @return {Promise} resolving to this\n   */\n  autoplay() {\n    const player = this.getPlayer();\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"Autoplaying\", player.name,\n                  \"using\", player.dictionary || this.dictionary);\n\n    let pre = ((player.delayBeforePlay || 0) > 0)\n        ? new Promise(\n          resolve => setTimeout(resolve, player.delayBeforePlay * 500))\n        : Promise.resolve();\n    let mid = ((player.delayBeforePlay || 0) > 0)\n        ? new Promise(\n          resolve => setTimeout(resolve, player.delayBeforePlay * 500))\n        : Promise.resolve();\n    // Before making a robot move, consider challenging the last\n    // player.\n    // challenge is a Promise that will resolve to true if a\n    // challenge is made, or false otherwise.\n    let lastPlay = this.lastTurn();\n    if (lastPlay && lastPlay.type === Game.Turns.PLAYED\n        && this.dictionary\n        && player.canChallenge) {\n      const lastPlayer = this.getPlayerWithKey(lastPlay.playerKey);\n      // There's no point if they are also a robot, though\n      // that should never arise in a \"real\" game where there can\n      // only be one robot.\n      if (!lastPlayer.isRobot) {\n        // use game dictionary, not robot dictionary\n        pre = pre.then(() => this.getDictionary())\n        .then(dict => {\n          const bad = lastPlay.words\n                .filter(word => !dict.hasWord(word.word));\n          if (bad.length > 0) {\n            // Challenge succeeded\n            /* c8 ignore next 2 */\n            if (this._debug)\n              this._debug(\"Challenging\", lastPlayer.name);\n            /* c8 ignore next 2 */\n            if (this._debug)\n              this._debug(\"Bad words:\", bad);\n            return this.takeBack(player, Game.Turns.CHALLENGE_WON)\n            .then(() => true);\n          }\n          return false; // no challenge made\n        });\n      }\n    }\n\n    return pre\n    .then(challenged => {\n      if (!challenged && lastPlay) {\n        // Last play was good, check the last player has tiles\n        // otherwise the game is over\n        const lastPlayer = this.getPlayerWithKey(lastPlay.playerKey);\n        if (lastPlayer.rack.isEmpty())\n          return this.confirmGameOver(player, Game.State.GAME_OVER);\n      }\n\n      // We can play.\n      let bestPlay = null;\n      return this.findBestPlay(\n        player.rack.tiles(),\n        data => {\n          if (typeof data === \"string\") {\n            /* c8 ignore next 2 */\n            if (this._debug)\n              this._debug(data);\n          } else {\n            bestPlay = data;\n            /* c8 ignore next 2 */\n            if (this._debug)\n              this._debug(\"Best\", bestPlay.stringify());\n          }\n        }, player.dictionary || this.dictionary)\n      .then(() => {\n        if (bestPlay)\n          return mid.then(() => this.play(player, bestPlay));\n\n        /* c8 ignore next 2 */\n        if (this._debug)\n          this._debug(player.name, \"can't play, passing\");\n        return this.pass(player, Game.Turns.PASSED);\n      });\n    });\n  }\n\n  /**\n   * Get the dictionary for this game, lazy-loading as necessary\n   * @return {Promise} promise resolves to a {@linkcode Dictionary}\n   */\n  getDictionary() {\n    /* c8 ignore next */\n    assert(this.dictionary, \"Game has no dictionary\");\n    return (0,_loadDictionary_js__WEBPACK_IMPORTED_MODULE_3__.loadDictionary)(this.dictionary);\n  }\n\n  /**\n   * Perform a save to the connected database (set in onLoad).\n   * @return {Promise} promise resolves to this\n   */\n  save() {\n    assert(this._db, \"No _db for save()\");\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"Saving game\", this.key);\n    return this._db.set(this.key, Game.toCBOR(this))\n    .then(() => this);\n  }\n\n  /**\n   * Send a notification to just one player, if they are connected\n   * through a channel. Note that the player\n   * may be connected multiple times through different channels.\n   * @param {Player} player player to send to\n   * @param {string} message to send\n   * @param {Object} data to send with message.\n   */\n  notifyPlayer(player, message, data) {\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"b>f\", player.key, message,\n                (0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(data));\n    // Player may be connected several times, or not at all\n    this._channels.forEach(\n      channel => {\n        if (channel.player && channel.player.key === player.key)\n          channel.emit(message, data);\n        return false;\n      });\n  }\n\n  /**\n   * Broadcast a notification to all game observers. Note\n   * that an observer may be connected multiple times,\n   * through different channels, or not at all.\n   * @param {string} message to send\n   * @param {Object} data to send with message\n   */\n  notifyAll(message, data) {\n    if (message !== Game.Notify.TICK)\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"b>f *\", message, (0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(data));\n    this._channels.forEach(channel => channel.emit(message, data));\n  }\n\n  /**\n   * Broadcast a notification to all observers except the\n   * given player.\n   * @param {Player} player player to exclude\n   * @param {string} message to send\n   * @param {Object} data to send with message\n   */\n  notifyOthers(player, message, data) {\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"b>f !\", player.key, message, (0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(data));\n    this._channels.forEach(\n      channel => {\n        // Player may be connected several times, so check key and not object\n        if (channel.player && channel.player.key !== player.key)\n          channel.emit(message, data);\n        return false;\n      });\n  }\n\n  /**\n   * Does player have an active connection to this game?\n   * @param {Player} player the player\n   * @return {Channel?} the connection channel, if connected.\n   */\n  getConnection(player) {\n    // TODO: move this to backend\n    if (player) {\n      for (const channel of this._channels) {\n        if (channel.player && channel.player === player) {\n          player._isConnected = true;\n          return channel;\n        }\n      }\n      player._isConnected = false;\n    }\n    return undefined;\n  }\n\n  /**\n   * Notify players with a list of the currently connected\n   * players, non-playing observers and non-connected players.\n   */\n  sendCONNECTIONS() {\n    Promise.all(\n      this.players\n      .map(player => player.serialisable(this)\n           .then(cat => {\n             cat.gameKey = this.key;\n             if (cat.key === this.whosTurnKey)\n               cat.isNextToGo = true;\n             return cat;\n           })))\n    .then(res => {\n      // Add observers who are not active players. These track\n      // game state without participating, though at some point\n      // we may add referreing functions.\n      res = res.concat(\n        this._channels\n        .filter(channel => !channel.player)\n        .map(() => {\n          return {\n            isObserver: true\n          };\n        }));\n      this.notifyAll(Game.Notify.CONNECTIONS, res);\n    });\n  }\n\n  /**\n   * Connect to a player front end via the given notification channel.\n   * Play the game if preconditions have been met.\n   * @param {Channel} channel the channel that will be\n   * used to send notifications to the front end for the given\n   * player.\n   * @param {string} playerKey the key identifying the player\n   * @return {Promise} promise that resolves to undefined\n   */\n  connect(channel, playerKey) {\n\n    // Make sure this is a valid (known) player\n    const player = this.players.find(p => p.key === playerKey);\n    /* c8 ignore next 2 */\n    if (playerKey && !player)\n      console.error(\"WARNING: player key\", playerKey,\n                    \"not found in game\", this.key);\n\n    /* c8 ignore next 2 */\n    if (this.getConnection(player)) {\n      console.error(\"WARNING:\", playerKey, \"already connected to\",\n                    this.key);\n      player._isConnected = true;\n    } else if (player) {\n      // This player is just connecting\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\t\", player.name, \"connected to\", this.key);\n      player._isConnected = true;\n    } else {\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\tconnected non-player\");\n    }\n\n    // Player is connected. Decorate the channel. It may seem\n    // rather cavalier writing over what might be a socket this\n    // way, but it does simplify the code quite a bit.\n    channel.game = this;\n    channel.player = player;\n\n    if (!this._channels)\n      this._channels = [];\n    this._channels.push(channel);\n\n    // Tell players that the player is connected\n    this.sendCONNECTIONS();\n\n    // Add disconnect listener\n    /* c8 ignore next */\n    channel.on(\"disconnect\", () => {\n      if (channel.player) {\n        channel.player._isConnected = false;\n        /* c8 ignore next 2 */\n        if (this._debug)\n          this._debug(channel.player.name, \"disconnected\");\n      } else {\n        /* c8 ignore next 2 */\n        if (this._debug)\n          this._debug(\"non-player disconnected\");\n      }\n      this._channels.splice(this._channels.indexOf(channel), 1);\n      this.sendCONNECTIONS();\n    });\n\n    return this.playIfReady();\n  }\n\n  /**\n   * Encode the data using CBOR and the Game type map.\n   * @param {object} data data to encode\n   * @param {function?} debug debug function passed to cbor encoder, same\n   * sig as console.debug.\n   */\n  static toCBOR(data, debug) {\n    // Debug function to find where a missing key is coming from\n    /*function sniffOut(data, what, path) {\n      if (typeof data === \"object\") {\n        if (Array.isArray(data)) {\n          for (const e of data)\n            sniffOut(e, what, `${path}[]`);\n        } else {\n          if (!data._sniffed) {\n            data._sniffed = true;\n            if (typeof data[what] !== \"undefined\") {\n              console.log(\"SNIFFED OUT\", data);\n              throw Error(path);\n            }\n            for (const k in data)\n              sniffOut(data[k], what, `${path}.${k}`);\n          }\n        }\n      }\n    }\n    sniffOut(data, \"babefacebabeface\", \"\");*/\n    CBOR_tagHandler.typeMap = Game.CLASSES;\n    return _cdot_cbor__WEBPACK_IMPORTED_MODULE_0__.Encoder.encode(data, CBOR_tagHandler, debug);\n  }\n\n  /**\n   * Decode the data using CBOR and the given type map.\n   * @param {ArrayBuffer|TypedArray|DataView} cbor data to decode\n   * @param {object.{string,object>} map from prototype name to prototype\n   * @param {function?} debug debug function passed to cbor decoder, same\n   * sig as console.debug.\n   */\n  static fromCBOR(cbor, typeMap, debug) {\n    CBOR_tagHandler.typeMap = typeMap;\n    try {\n      return _cdot_cbor__WEBPACK_IMPORTED_MODULE_0__.Decoder.decode(cbor, CBOR_tagHandler, debug);\n    } catch (e) {\n      // Maybe Fridge? Old format.\n      if (debug)\n        debug(\"CBOR error decoding:\\n\", e.message);\n\n      // Compatibility; try using Fridge, versions of FileDatabase\n      // prior to 3.1.0 used it.\n      try {\n        return _common_Fridge_js__WEBPACK_IMPORTED_MODULE_2__.Fridge.thaw(cbor.toString(), typeMap);\n      } catch (e) {\n        throw Error(`Thawing error: ${e}`);\n      }\n    }\n  }\n\n  /**\n   * Used for testing only.\n   * @param sboard string representation of a game {@linkcode Board}\n   * @return {Promise} resolving to `this`\n   */\n  loadBoard(sboard) {\n    return this.getEdition()\n    .then(ed => this.board.parse(this.constructor.CLASSES, ed, sboard))\n    .then(() => this);\n  }\n\n  /**\n   * @callback Platform~bestMoveCallback\n   * @param {(Move|string)} best move found so far, or a\n   * progress string for debug (only intended for developer)\n   */\n\n  /**\n   * Find the best play. This is used to abstract\n   * the best play controller from the rest of the server code,\n   * so it can be invoked either directly or asynchronously.\n   * @param {Game} game the Game\n   * @param {Tile[]} rack rack in the form of a simple list of Tile\n   * @param {Platform~bestMoveCallback} cb accepts a best play\n   * whenever a new one is found, or a string containing a\n   * message\n   * @param {string?} dictionary name of (or path to) dictionary to\n   * override the game dictionary\n   * @return {Promise} Promise that resolves when all best moves\n   * have been tried\n   * @abstract\n   */\n  findBestPlay(rack, cb, dictionary) {\n    return (Platform.USE_WORKERS\n            ? __webpack_require__.e(/*! import() | findBestPlayController */ \"findBestPlayController\").then(__webpack_require__.bind(__webpack_require__, /*! ../backend/findBestPlayController.js */ \"./src/backend/findBestPlayController.js\"))\n            : __webpack_require__.e(/*! import() | findBestPlay */ \"findBestPlay\").then(__webpack_require__.bind(__webpack_require__, /*! ../game/findBestPlay.js */ \"./src/game/findBestPlay.js\")))\n    .then(mod => mod.findBestPlay(this, rack, cb, dictionary));\n  }\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Game.js?");

/***/ }),

/***/ "./src/game/LetterBag.js":
/*!*******************************!*\
  !*** ./src/game/LetterBag.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LetterBag\": () => (/* binding */ LetterBag)\n/* harmony export */ });\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ \"./src/game/Tile.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/* global assert */\n\n\n\n/**\n * The bag of letters during a game.\n */\nclass LetterBag {\n\n  /**\n   * Array of Tiles in the bag\n   * @member {Tile[]}\n   */\n  tiles = [];\n\n  /**\n   * Array of all the letters in the bag, excluding blank.\n   * @member {string}\n   */\n  legalLetters = [];\n\n  /**\n   * Construct a new letter bag using the distribution for the\n   * given edition\n   * @param {Edition|LetterBag} edition the Edition defining the\n   * bag contents. Can also be an existing LetterBag to give a predictable,\n   * non-random bag\n   */\n  constructor(edition) {\n    if (edition instanceof LetterBag) {\n      /**\n       * Set to disable shuffling the bag. This is used when\n       * replaying moves, when we need a predictable set for tiles\n       * to be delivered next out of the bag.\n       * @member {boolean?}\n       */\n      this.predictable = true;\n\n      for (const tile of edition.tiles)\n        this.tiles.push(new _Tile_js__WEBPACK_IMPORTED_MODULE_0__.Tile(tile));\n      // Don't shake, we want it predictable!\n    } else {\n      for (let letter of edition.bag) {\n        // legalLetters is an array, not a string, to support\n        // multi-character tiles\n        if (!letter.isBlank)\n          // Not blank\n          this.legalLetters.push(letter.letter);\n\n        const count = Math.floor(letter.count);\n        for (let n = 0; n < count; ++n) {\n          const tile = new _Tile_js__WEBPACK_IMPORTED_MODULE_0__.Tile({\n            letter:  letter.letter,\n            score: letter.score\n          });\n          if (letter.isBlank)\n            tile.isBlank = true;\n          this.tiles.push(tile);\n        }\n      }\n      this.shake();\n    }\n\n    if (edition.isWild) // never true, doc only\n      /**\n       * Whether this bag is wild or not. When a bag is wild, any tile\n       * taken from in the bag can be used as any other tile. This is\n       * used client-side, where we are only concerned about the number\n       * of tiles left in the bag and we want to prevent reverse\n       * engineering of bag and rack contents. By default, bags are not\n       * wild.\n       * @member {boolean?}\n       */\n      this.isWild = true;\n  }\n\n  /**\n   * Test bag for emptiness\n   * @return {boolean} true if there are no tiles in the bag\n   */\n  isEmpty() {\n    return this.tiles.length === 0;\n  }\n\n  /**\n   * Randomize tiles in-place using Durstenfeld shuffle. Randomness\n   * can be disabled by setting {@linkcode LetterBag#predictable}\n   */\n  shake() {\n    if (this.predictable || this.isWild) {\n      return;\n    }\n\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n    for (let i = this.tiles.length - 1; i > 1; i--) {\n      // j  random integer such that 0  j  i\n      // Note that j < i turns this into Sattolo's algorithm (wrong)\n      const j = Math.floor(Math.random() * (i + 1));\n      if (j === i)\n        continue;\n      const temp = this.tiles[i];\n      this.tiles[i] = this.tiles[j];\n      this.tiles[j] = temp;\n    }\n    //console.debug(\"Initial bag\", this.tiles.map(t => t.letter));\n  }\n\n  /**\n   * Get a single random tile from the bag. Assumes the bag is\n   * already randomised, and there is no need to shuffle it\n   * again.\n   * @return {Tile} a Tile or undefined if there are no tiles left\n   */\n  getRandomTile() {\n    if (this.tiles.length > 0)\n      return this.tiles.pop();\n    return undefined;\n  }\n\n  /**\n   * Remove count random tiles from the bag. Assumes the bag is\n   * already randomised, and there is no need to shuffle it\n   * again. Note that you cannot get random tiles from a wild bag.\n   * @return {Tile[]} 'count' Tile. If there aren't enough\n   * tiles in the bag, may return a shorter array.\n   */\n  getRandomTiles(count) {\n    assert(!this.isWild, \"Bag is wild\");\n    const tiles = [];\n    console.assert(count >= 0, \"Bag is empty\");\n    for (let i = 0; this.tiles.length > 0 && i < count; i++)\n      tiles.push(this.getRandomTile());\n    return tiles;\n  }\n\n  /**\n   * Return a tile to the bag, and give it a shoogle so the same\n   * tile doesn't always re-emerge next.\n   * @param {Tile} tile tile to return to bag\n   */\n  returnTile(tile) {\n    this.tiles.push(tile.reset(this.isWild));\n    this.shake();\n  }\n\n  /**\n   * Return an array of tiles to the bag, and give it a shimmy\n   * @param {Tile[]} tiles tiles to return to bag\n   */\n  returnTiles(tiles) {\n    for (const tile of tiles)\n      this.tiles.push(tile.reset(this.isWild));\n    this.shake();\n  }\n\n  /**\n   * Remove a matching tile from the bag. Either the exact tile\n   * will be matched or a tile that represents the same letter.\n   * Blanks only match blanks.\n   * If the bag is wild, we simply pop a tile, make it look like\n   * the requested tile, and return it.\n   * @param {Tile} tile tile to match in the bag\n   * @return {Tile?} the tile removed, or undefined if it wasn't found\n   */\n  removeTile(tile) {\n    if (this.isWild)\n      // Grab a tile, any tile\n      return this.tiles.pop().copy(tile);\n    for (let i = 0; i < this.tiles.length; i++) {\n      const t = this.tiles[i];\n      if (t === tile\n          || (t.isBlank && tile.isBlank)\n          || (!t.isBlank && !tile.isBlank && t.letter === tile.letter))\n      {\n        this.tiles.splice(i, 1);\n        return t;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Take a list of matching tiles out of the letter bag.\n   * @param {Tile[]} tiles list of tiles to match and remove\n   * @return {Tile[]} list of tiles removed from the bag\n   */\n  removeTiles(tiles) {\n    const unbagged = [];\n    for (const tile of tiles)\n      unbagged.push(this.removeTile(tile));\n    return unbagged;\n  }\n\n  /**\n   * How many tiles remain?\n   * @return {number} number of tiles still in the bag\n   */\n  remainingTileCount() {\n    return this.tiles.length;\n  }\n\n  /**\n   * Return an unsorted list of letters in the bag\n   * @return {string[]} array of letters\n   */\n  letters() {\n    return this.tiles.map(tile => tile.letter);\n  }\n\n  /* c8 ignore start */\n\n  /**\n   * Generate a simple string representation of the bag\n   */\n  stringify() {\n    return \"(\" + this.letters().sort().join(\"\") + \")\";\n  }\n\n  /* c8 ignore stop */\n}\n\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/LetterBag.js?");

/***/ }),

/***/ "./src/game/Move.js":
/*!**************************!*\
  !*** ./src/game/Move.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Move\": () => (/* binding */ Move)\n/* harmony export */ });\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ \"./src/game/Tile.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n\n\n/**\n * A collection of tile placements, and the delta score\n * achieved { for } the move. We also record the words created by the\n * move {. It } is used to send a human player's play to the server,\n * which { then } sends a matching {@linkcode Turn} to every player.\n */\nclass Move {\n\n  /**\n   * Score for the play.\n   * If a number, change in score for the player as a result of\n   * this move. If an object, change in score for each\n   * player, indexed by player key. The object form is only used\n   * in Turn.\n   * @member {number|object}\n   */\n  score;\n\n  /**\n   * @param {(Move|object)?} params Move to copy, or params, or undefined\n   * Any member can be initialised by a corresponding field in\n   * params.\n   */\n  constructor(params) {\n\n    if (params.words)\n      /**\n       * List of words created by the play:\n       * ```\n       * { word: string, score: number }\n       * @member {object[]?}\n       */\n      this.words = params.words;\n\n    this.score = params ? (params.score || 0) : 0;\n\n    if (params.placements)\n      /**\n       * List of tiles placed in this move. Tiles are required\n       * to carry col, row positions where they were placed.  In\n       * a Turn, for type=`move` it indicates the move. For\n       * `Game.Turns.TOOK_BACK` and `Game.Turns.CHALLENGE_WON` it is\n       * the move just taken back/challenged.\n       * Note that we instatiate game Tiles, without taking account\n       * of the context of the call; Move is used for comms\n       * between front and ack ends, and the tiles therein don't\n       * need customised functionality.\n       * @member {Tile[]?}\n       */\n      this.placements = params.placements.map(\n        tilespec => new _Tile_js__WEBPACK_IMPORTED_MODULE_0__.Tile(tilespec));\n  }\n\n  /**\n   * Add a Tile placement to the move\n   * @param {Tile} tile the Tile to add\n   */\n  addPlacement(tile) {\n    if (this.placements)\n      this.placements.push(tile);\n    else\n      this.placements = [tile];\n  }\n\n  /**\n   * String representation for debugging\n   */\n  stringify() {\n    const pl = this.placements ?\n          this.placements.map(t => t.stringify(true))\n          : \"<no placements>\";\n    const w = this.words ?\n          this.words.map(w => `${w.word}(${w.score})`)\n          : \"<no words>\";\n    return `Move ${pl} words ${w} for ${this.score}`;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Move.js?");

/***/ }),

/***/ "./src/game/Player.js":
/*!****************************!*\
  !*** ./src/game/Player.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => (/* binding */ Player)\n/* harmony export */ });\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/**\n * A player in a {@linkcode Game}. Player objects are specific to\n * a single game, and are used on both browser and server sides.\n */\nclass Player {\n\n  // Note that we do NOT use the field syntax for the fields that\n  // are serialised. If we do that, then the constructor blows the\n  // field away when loading CBOR.\n\n  /**\n   * @param {object} spec named parameters, or other Player\n   * object to copy. `name` and `key ` are required. Any of `_debug`,\n   * `isRobot`, `canChallenge`, `wantsAdvice`,`dictionary` or\n   * `missNextTurn` can be passed. The player will be initialised with\n   * an empty rack (no squares).\n   * @param {object.<string,class>} factory maps class name to a class\n   */\n  constructor(spec, factory) {\n\n    /**\n     * Factory object used to create this object (not serialiable)\n     * @private\n     */\n    this._factory = factory;\n\n    /**\n     * Player unique key. Required.\n     * @member {Key}\n     */\n    this.key = spec.key;\n\n    /**\n     * Player name. Required.\n     * @member {string}\n     */\n    this.name = spec.name;\n\n    /**\n     * Rack of tiles. By default an 8-cell rack is created, but\n     * this will be replaced on a call to fillRack, as\n     * it's only then we know how big it has to be.\n     * @member {Rack}\n     */\n    this.rack = new this._factory.Rack(\n      this._factory, {id: `Rack_${this.key}`, size: 8 });\n\n    /**\n     * Number of times this player has passed (or swapped)\n     * since the last non-pass/swap play.\n     * @member {number}\n     */\n    this.passes = 0;\n\n    /**\n     * Player's current score.\n     * @member {number}\n     */\n    this.score = 0;\n\n    if (spec.clock)\n      /**\n       * Player countdown clock. In games with `timerType` `TIMER_TURN`,\n       * this is the number of seconds before the player's turn times\n       * out (if they are the current player). For `TIMER_GAME` it's\n       * the number of seconds before the chess clock runs out.\n       * Setting and management is done in {@linkcode Game}\n       * @member {number?}\n       */\n      this.clock = 0;\n\n    if (spec._isConnected)\n      /**\n       * Whether the backend thinks the player is connected or not.\n       * Not serialised.\n       * @member {boolean?}\n       */\n      this._isConnected = true;\n\n    if (spec.missNextTurn)\n      /**\n       * True if this player is due to miss their next play due\n       * to a failed challenge. Default is false.\n       * @member {boolean?}\n       */\n      this.missNextTurn = true;\n\n    if (spec.wantsAdvice)\n      /**\n       * Set true to advise human player of better plays than the one\n       * they used. Default is false.\n       * @member {boolean?}\n       */\n      this.wantsAdvice = true;\n\n    if (spec.isRobot)\n      /**\n       * Is player a robot? Default is false.\n       * @member {boolean?}\n       */\n      this.isRobot = true;\n\n    if (spec.canChallenge)\n      /**\n       * Can robot player challenge? Default is false.\n       * @member {boolean?}\n       */\n      this.canChallenge = true;\n\n    if (spec.dictionary)\n      /**\n       * Name of (or path to) the dictionary the robot will use. Defaults to\n       * the game dictionary. Only used for findBestPlay for robot players.\n       * Default is undefined.\n       * @member {string?}\n       */\n      this.dictionary = spec.dictionary;\n\n    if (spec.delayBeforePlay && spec.delayBeforePlay > 0)\n      /**\n       * Number of seconds that a robot player must wait before it\n       * can play it's move. This delay is to give the revious player\n       * time to take back their move (or just think!)\n       * @member {number?}\n       */\n      this.delayBeforePlay = spec.delayBeforePlay;\n\n    /**\n     * Debug function\n     * @member {function?}\n     */\n    this._debug = spec._debug;\n  }\n\n  /**\n   * Create simple flat structure describing a subset of the player\n   * state. This is used for sending minimal player information to\n   * the `games` interface using JSON.\n   * @param {Game} game the game the player is participating in\n   * @param {UserManager?} um user manager for getting emails if wanted\n   * @return {Promise} resolving to a simple structure describing\n   * the player\n   */\n  serialisable(game, um) {\n    return ((this.isRobot || !um)\n            ? Promise.resolve(this)\n            : um.getUser({ key: this.key }).catch(() => this))\n    .then(ump => {\n      const simple = {\n        name: this.name,\n        key: this.key,\n        score: this.score\n      };\n      if (this.isRobot) simple.isRobot = true;\n      if (this._isConnected) simple._isConnected = true;\n      if (this.dictionary) simple.dictionary = this.dictionary;\n      if (this.clock) simple.clock = this.clock;\n\n      // Can they be emailed?\n      if (ump.email) simple.email = true;\n\n      if (this.missNextTurn) simple.missNextTurn = true;\n\n      return simple;\n    });\n  }\n\n  /**\n   * Construct a player object from a structure generated by\n   * serialisable()\n   * @param {object} factory class object mapping class name to a class\n   * @param {object} simple object generated by serialisable()\n   */\n  static fromSerialisable(simple, factory) {\n    const player = new factory.Player(simple, factory);\n    if (simple.passes)\n      player.passes = simple.passes;\n    if (simple.score)\n      player.score = simple.score;\n    if (simple.clock)\n      player.clock = simple.clock;\n    return player;\n  }\n\n  /**\n   * Draw an initial rack from the letter bag.\n   * @param {LetterBag} letterBag LetterBag to draw tiles from. Note that\n   * tiles are copied, with the copy being constructed using the\n   * factory that was passed to the constructor.\n   * @param {number} rackSize size of the rack\n   */\n  fillRack(letterBag, rackSize) {\n    // +1 to allow space for tile sorting in the UI\n    // Use the player key for the rack id, so we can maintain\n    // unique racks for different players\n    this.rack = new (this._factory.Rack)(\n      this._factory, { id: `Rack_${this.key}`, size: rackSize + 1 });\n    for (let i = 0; i < rackSize; i++)\n      this.rack.addTile(new (this._factory.Tile)(letterBag.getRandomTile()));\n    this.score = 0;\n  }\n\n  /**\n   * Return all tiles to the letter bag.\n   * @param {LetterBag} letterBag LetterBag to return tiles to\n   */\n  returnTiles(letterBag) {\n    for (let tile of this.rack.tiles())\n      letterBag.returnTile(this.rack.removeTile(tile));\n  }\n\n  /**\n   * Handle a tick of the server clock.\n   */\n  tick() {\n    this.clock--;\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"Tick\", this.name, this.clock);\n    if (this.clock <= 0 && typeof this._onTimeout === \"function\") {\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(this.name, \"has timed out at\", new Date());\n      this._onTimeout();\n      // Timeout only happens once!\n      delete this._onTimeout;\n    }\n  }\n\n  /**\n   * Set a timeout for the player, which will be triggered when the\n   * clock reaches exactly 0. The timeout is only triggered once for\n   * a call to setTimeout, resetting the clock will not invoke it\n   * again.\n   * @param {number} time number of seconds before timeout\n   * @param {function} onTimeout a function() invoked if the\n   * timer expires, ignored if time undefined\n   */\n  setTimeout(time, onTimeout) {\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(this.name, `turn timeout in ${time}s`);\n    this.clock = time;\n    this._onTimeout = onTimeout;\n  }\n\n  /**\n   * Generate debug representation\n   */\n  stringify() {\n    let s = `Player '${this.name}'`;\n    if (this.isRobot)\n      s += \" (Robot)\";\n    if (this.key)\n      s += ` key ${this.key}`;\n    s += ` rack \"${this.rack.letters().sort().join(\"\")}\"`;\n    return s + ` score ${this.score}`;\n  }\n\n  /**\n   * Toggle wantsAdvice on/off\n   */\n  toggleAdvice() {\n    this.wantsAdvice = !this.wantsAdvice;\n  }\n\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Player.js?");

/***/ }),

/***/ "./src/game/Rack.js":
/*!**************************!*\
  !*** ./src/game/Rack.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rack\": () => (/* binding */ Rack)\n/* harmony export */ });\n/* harmony import */ var _common_Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Utils.js */ \"./src/common/Utils.js\");\n/* harmony import */ var _Surface_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Surface.js */ \"./src/game/Surface.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n\n\n\n/**\n * A Rack is a set of tiles that a player can play from. It's\n * a 1D array of Square; a 1-column {@linkcode Surface}\n */\nclass Rack extends _Surface_js__WEBPACK_IMPORTED_MODULE_1__.Surface {\n\n  // Note that we do NOT use the field syntax for the fields that\n  // are serialised. If we do that, then the constructor blows the\n  // field away when loading using CBOR.\n\n  /**\n   * @param {object.<string,class>} factory object mapping class name to a class\n   * @param {Rack|object} spec specification of the rack, or a rack to copy\n   * @param {string|Rack} spec.id unique id for this rack, or a rack to copy.\n   * The squares and the tiles they carry will be copied as well.\n   * @param {number} spec.size rack size\n   * @param {string?} spec.underlay text string with one character for\n   * each cell in UI of the rack. This is the SWAP string that\n   * underlies the swap rack.\n   */\n  constructor(factory, spec) {\n    // The id will be used as the base for generating the id's\n    // for the Squares in the underlying Surface. Note that\n    // the UI will have Rack objects for the player rack and\n    // the swap rack, but will also have racks that have no UI\n    // for the other players. The ID for these racks must be\n    // player specific.\n    if (spec instanceof Rack) {\n      // Copy constructor\n      // Only used in game simulation. Underlay not supported.\n      super(factory, {\n        id: spec.id,\n        cols: spec.cols,\n        rows: 1,\n        type: () => \"_\"\n      });\n      spec.forEachTiledSquare(square => {\n        this.addTile(new factory.Tile(square.tile));\n        return false;\n      });\n    } else {\n      super(factory, {\n        id: spec.id,\n        cols: spec.size,\n        rows: 1,\n        type: () => \"_\"\n      });\n    }\n\n    /**\n     * Whether this rack is wild or not. When a rack is wild, the tiles\n     * taken from in the rack can be used as any other tile. This is\n     * used client-side, for players other than the current player.\n     */\n    if (spec.isWild)\n      this.isWild = true;\n\n    if (typeof spec.underlay !== \"undefined\") {\n      let idx = 0;\n      this.forEachSquare(square => {\n        square.setUnderlay(spec.underlay.charAt(idx++));\n        return idx === spec.underlay.length;\n      });\n    }\n  }\n\n  /**\n   * Add a Tile to the rack\n   * @param {Tile} tile the Tile to add, must != null\n   * @return {Square?} the square where the tile was placed\n   * (undefined if it couldn't be placed)\n   */\n  addTile(tile) {\n    let rackSquare;\n    tile.reset(this.isWild);\n    this.forEachEmptySquare(square => {\n      rackSquare = square;\n      square.placeTile(tile);\n      return true;\n    });\n    return rackSquare;\n  }\n\n  /**\n   * Put tiles back on the rack.\n   * @param {Tile[]} tiles list of tiles\n   * @return {Square[]} squares the tiles were placed on\n   */\n  addTiles(tiles) {\n    return tiles.map(tile => this.addTile(tile));\n  }\n\n  /**\n   * Get an unsorted list of the letters currently on the rack.\n   * Blanks are represented by a space.\n   * @return {string[]}\n   */\n  letters() {\n    return this.tiles().map(tile => tile.letter);\n  }\n\n  /**\n   * Find the Square that contains a Tile that can represent\n   * the given letter.\n   * If a letter tile can't be found, a blank will be used if there\n   * is one.\n   * @param {string} letter the letter to find\n   * @return {Square} carrying a matching tile, or undefined\n   */\n  findSquare(letter) {\n    let square;\n    this.forEachTiledSquare(sq => {\n      if (this.isWild)\n        square = sq;\n      else if (!square && sq.tile.isBlank || sq.tile.letter === letter)\n        square = sq;\n    });\n\n    return square;\n  }\n\n  /**\n   * Find and remove a tile from the rack.\n   * @param {Tile?} remove if defined, the tile removed must match\n   * this tile. If undefined, any tile can be removed.\n   * @return {Tile} the removed tile\n   */\n  removeTile(remove) {\n    const letter = remove.letter;\n    const square = this.findSquare(letter);\n    if (!square)\n      throw Error(`Cannot find '${letter}' on ${this.stringify()}`);\n    const tile = square.tile;\n    square.unplaceTile();\n    if (this.isWild)\n      tile.copy(remove);\n    else if (tile.isBlank)\n      tile.letter = letter;\n    return tile;\n  }\n\n  /**\n   * Take tiles out of the rack\n   * @param {Tile[]} tiles list of tiles\n   * @param {Rack} rack rack\n   * @return {Tile[]} list of tiles removed\n   */\n  removeTiles(tiles) {\n    const racked = [];\n    for (const tile of tiles) {\n      const removed = this.removeTile(tile);\n      if (!removed)\n        throw Error(`${(0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_0__.stringify)(tile)} missing from rack`);\n      racked.push(removed);\n    }\n    return racked;\n  }\n\n  /**\n   * Shuffle tile positions within the rack\n   * @return {Rack} this\n   */\n  shuffle() {\n    const tiles = [];\n    let i;\n    for (i = 0; i < this.cols; i++) {\n      const square = this.at(i);\n      if (square.tile)\n        tiles.push(square.unplaceTile());\n    }\n    for (i = tiles.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = tiles[i];\n      tiles[i] = tiles[j];\n      tiles[j] = temp;\n    }\n    this.addTiles(tiles);\n\n    return this;\n  }\n\n  /**\n   * Get a list of letters on the rack that are not blanks\n   * @return {string[]}\n   */\n  lettersLeft() {\n    return this.tiles().filter(tile => !tile.isBlank)\n    .map(tile => tile.letter);\n  }\n\n  /* c8 ignore start */\n\n  /**\n   * Debug\n   */\n  stringify() {\n    return `[${this.tiles().map(t => (0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_0__.stringify)(t)).join(\",\")}]`;\n  }\n  /* c8 ignore stop */\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Rack.js?");

/***/ }),

/***/ "./src/game/Replay.js":
/*!****************************!*\
  !*** ./src/game/Replay.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Replay\": () => (/* binding */ Replay)\n/* harmony export */ });\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game.js */ \"./src/game/Game.js\");\n/*Copyright (C) 2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n\nconst LetterBag = _Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.LetterBag;\nconst Board = _Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Board;\nconst Player = _Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Player;\nconst Tile = _Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Tile;\nconst Rack = _Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Rack;\nconst Turn = _Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES.Turn;\n\n/**\n * Extend Game to support replay of another game. Requires\n * {@linkcode game/Undo} and {@linkcode game/Commands}\n * to be mixed in.\n * @mixin game/Replay\n */\nconst Replay = superclass => class extends superclass {\n\n  /*\n   * Replay the turns in another game, to arrive at the same state.\n   * The letter bag, players, and some other conditions\n   * are copied from the other game, and each turn is undone\n   * back to the game's initial state. Then each turn is replayed.\n   * all players are played as human players - there is no move\n   * computation done.\n   * Usage\n   * ```\n   * let simulation = new Game(gameToPlay).replay(gameToPlay)\n   * for (let i = 0; i < gameToPlay.turns.length)\n   *    simulation.step();\n   * ```\n   * @param {Game} playedGame the game containing turns and players\n   * to simulate.\n   * @instance\n   * @memberof game/!Replay\n   */\n  replay(playedGame) {\n    this.game = playedGame;\n    this.allowUndo = true;\n    // Reset to the first turn\n    this.nextTurn = 0;\n    // Override the bag and board (this is what create() would do)\n    this.letterBag = new LetterBag(this.game.letterBag);\n    this.board = new Board(_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES, this.game.board);\n    this.bonuses = this.game.bonuses;\n    this.rackSize = this.game.rackSize;\n    this.swapSize = this.game.swapSize;\n    this.state = _Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.State.PLAYING;\n    this.whosTurnKey = this.game.turns[0].playerKey;\n\n    // Copy players and their racks.\n    for (const p of this.game.players) {\n      const np = new Player(p, _Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES);\n      np.isRobot = false;\n      np.rack = new Rack(_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.CLASSES, p.rack);\n      np.passes = p.passes;\n      np.score = p.score;\n      this.addPlayer(np);\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\tlast rack for\", np.key, \"was\", np.rack.stringify());\n    }\n\n    // Copy the board\n    this.game.board.forEachTiledSquare(\n      (square, c, r) => {\n        this.board.at(c, r).tile = new Tile(square.tile);\n        return false;\n      });\n\n    // Remember the initial bag tiles\n    //const preUndoBag = new LetterBag(this.game.letterBag).tiles;\n\n    // To get back to the initial game state we have to run through\n    // the turn history backwards to reconstruct initial racks.\n    // Could use Undo to do this, but it's overkill as we don't need\n    // (or want) to modify the board\n    const turns = this.game.turns;\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"unwrap\", turns.length, \"turns\");\n    for (let i = this.game.turns.length - 1; i >= 0; i--) {\n      const turn = this.game.turns[i];\n      this.undo(turn, true);\n      /*const tiles = this.letterBag.letters();\n        this._debug(\n        `Bag  \"${this.letterBag.letters().sort().join(\"\")}\"`);\n        const ts =\n        this.board.tiles().map(bt => bt.isBlank ? \" \" : bt.letter);\n        this._debug(`Board\"${ts.sort().join(\"\")}\"`);\n        tiles.push(ts);\n        for (const p of this.players) {\n        tiles.push(p.rack.letters());\n        this._debug(`Rack \"${p.rack.letters().sort().join(\"\")}\"`);\n        }\n        this._debug(`All  \"${tiles.flat().sort().join(\"\")}\"`);*/\n    }\n\n    for (const pl of this.players) {\n      pl.missNextTurn = false;\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"Start player\", pl.stringify());\n    }\n    /* c8 ignore next 2 */\n    if (this._debug) {\n      this._debug(\"Start bag\", this.letterBag.stringify());\n      this._debug(\"--------------------------------\");\n    }\n\n    return this;\n  }\n\n  /**\n   * Promise to perform a single step in the simulation\n   * @instance\n   * @memberof game/Replay\n   * @return {Promise} promise that resolves to the simulated turn when\n   * the simulation step has been run\n   */\n  step() {\n    // Copy the turn to avoid accidental overwrite\n    const turn = new Turn(this.game.turns[this.nextTurn++]);\n    turn.gameKey = this.key;\n    return this.redo(turn) // redo comes from Undo.js\n    .then(() => {\n      /* c8 ignore next 5 */\n      if (this._debug) {\n        for (const pl of this.players)\n          this._debug(pl.stringify());\n        this._debug(\"---------------------\");\n      }\n      return turn;\n    });\n  }\n};\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Replay.js?");

/***/ }),

/***/ "./src/game/Square.js":
/*!****************************!*\
  !*** ./src/game/Square.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Square\": () => (/* binding */ Square)\n/* harmony export */ });\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/**\n * A square on the game board or rack. A Tile holder with some\n * underlying attributes; a position, an owner type, and a type that\n * dictates the score multipliers that apply. The owner will be a\n * subclass of {@linkcode Surface} (a {@linkcode Rack} or a {@linkcode Board})\n */\nclass Square {\n\n  // Note that we do NOT use the field syntax for the fields that\n  // are serialised. If we do that, then the constructor blows the\n  // field away when loading using CBOR.\n\n  /**\n   * @param {object} spec Specification\n   * @param {string} spec.type /^[QqTtSs_]$/ see {@linkcode Board}\n   * @param {Surface} spec.surface Surface the square is on\n   * @param {number} spec.col 0-based column where the square is\n   * @param {number?} spec.row 0-based row where the square is\n   * (undefined on a rack)\n   */\n  constructor(spec) {\n\n    /**\n     * /^[QqTtSs_]$/ see {@linkcode Board}\n     * @member {string}\n     */\n    this.type = spec.type;\n\n    /**\n     * Surface the square is on\n     * @member {Surface}\n     */\n    this.surface = spec.surface;\n\n    /**\n     * 0-based column where the square is.\n     * @member {number}\n     */\n    this.col = spec.col;\n\n    if (typeof spec.row !== \"undefined\") {\n      /**\n       * 0-based row where the square is (undefined on a 1D surface).\n       * @member {number?}\n       */\n      this.row = spec.row;\n    }\n\n    if (spec.tile) {\n      /**\n       * Tile placed on this square\n       * @member {Tile?}\n       */\n      this.tile = spec.tile;\n    }\n\n    if (spec.underlay)\n      /**\n       * Underlay character to put in the background of the square when\n       * there is no tile present.\n       * @member {string?}\n       */\n      this.underlay = spec.underlay;\n\n    // Determine score multipliers from type\n    switch (this.type) {\n    case \"d\":\n      /**\n       * Multiplier for letters using this square. Defaults to 1 if undefined.\n       * @member {number?}\n       */\n      this.letterScoreMultiplier = 2;\n      break;\n    case \"t\": this.letterScoreMultiplier = 3; break;\n    case \"q\": this.letterScoreMultiplier = 4; break;\n    case \"M\":\n    case \"D\":\n      /**\n       * Multiplier for words using this square. Defaults to 1 if undefined.\n       * @member {number?}\n       */\n      this.wordScoreMultiplier = 2;\n      break;\n    case \"T\": this.wordScoreMultiplier = 3; break;\n    case \"Q\": this.wordScoreMultiplier = 4; break;\n    }\n  }\n\n  /**\n   * Flag indicating if this square is at a 2D position and\n   * therefore on the game board.\n   * @return {boolean}\n   */\n  get isBoard() {\n    if (this.isOnBoard) // Compatibility - old game file format\n      return true;\n    return typeof this.row !== \"undefined\";\n  }\n\n  /**\n   * @return true if the square doesn't have a tile placed on it\n   */\n  isEmpty() {\n    return !this.tile;\n  }\n\n  /**\n   * @return {boolean} true if a tile is placed and it is locked\n   */\n  hasLockedTile() {\n    // tileLocked is used in very old games\n    return this.tile && (this.tileLocked || this.tile.isLocked);\n  }\n\n  /**\n   * Place a tile on this square. Tiles are locked when a play is\n   * committed to a Board.\n   * @param {Tile} tile the tile to place\n   * @param {boolean} [lock] whether the tile is to be locked to\n   * the square (fixed on the board).\n   * @return true if the tile is placed, false otherwise.\n   */\n  placeTile(tile, lock) {\n    /* c8 ignore next 2 */\n    if (this.tile && this.tile !== tile)\n      throw Error(\"Square already occupied\");\n\n    tile.col = this.col;\n    if (typeof this.row !== \"undefined\")\n      tile.row = this.row;\n    tile.isLocked = lock;\n    if (tile === this.tile)\n      return false; // Tile hasn't changed\n    this.tile = tile;\n    return true;\n  }\n\n  /**\n   * Remove the tile placed on this square.\n   * @return {Tile?} tile unplaced from the square, if any\n   */\n  unplaceTile() {\n    // Note that a locked tile might be unplaced as\n    // part of undoing a challenged play. Only then should\n    // the tile letter be reset.\n    const unplaced = this.tile;\n    if (unplaced) {\n      unplaced.reset(); // clear letter and lock\n      delete this.tile;\n      return unplaced;\n    }\n    return undefined;\n  }\n\n  /* c8 ignore start */\n\n  /**\n   * Generate debug representation\n   */\n  stringify() {\n    // All squares have a col\n    let string = `#${this.type}@${this.col}`;\n    // Squares on the board have a row too\n    if (this.row >= 0)\n      string += \",\" + this.row;\n\n    if (this.tile)\n      string += `<=${this.tile.stringify()}`;\n    return string;\n  }\n  /* c8 ignore stop */\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Square.js?");

/***/ }),

/***/ "./src/game/Surface.js":
/*!*****************************!*\
  !*** ./src/game/Surface.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Surface\": () => (/* binding */ Surface)\n/* harmony export */ });\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/**\n * Abstract base class of a 2D grid of {@linkcode Sqaure} (a Rack or a Board)\n */\nclass Surface {\n\n  // Note that we do NOT use the field syntax for the fields that\n  // are serialised. If we do that, then the constructor blows the\n  // field away when loading using CBOR.\n\n  /**\n   * @param {object.<string,class>} factory maps class name to a class\n   * @param {object} spec specification of the surface\n   * @param {string} spec.id unique id for the surface\n   * @param {number} spec.cols number of columns\n   * @param {number} spec.rows number of rows (1 for a rack)\n   * @param {function} spec.type function(col, row) returning the square type\n   */\n  constructor(factory, spec) {\n\n    /**\n     * Unique id for the surface. This is used in the construction\n     * of HTML id attributes for the Squares it contains.\n     * @member {string}\n     */\n    this.id = spec.id;\n\n    /**\n     * Number of columns on the surface.\n     * @member {number}\n     */\n    this.cols = spec.cols;\n\n    /**\n     * Number of rows on the surface. This will be 0 for a Rack.\n     * @member {number}\n     */\n    this.rows = spec.rows;\n\n    /**\n     * rows X cols array of squares\n     * @member {Square[][]}\n     * @private\n     */\n    this.squares = [];\n\n    for (let i = 0; i < this.cols; i++) {\n      const row = [];\n      for (let j = 0; j < this.rows; j++) {\n        const sq = {\n          type: spec.type(i, j),\n          surface: this,\n          col: i\n        };\n        if (spec.rows > 1)\n          sq.row = j;\n        row.push(new factory.Square(sq));\n      }\n      this.squares.push(row);\n    }\n  }\n\n  /**\n   * Get the square at [col][row]\n   * @param {number} col the column containing the square\n   * @param {number?} row the column containing the square, 0 if undefined\n   */\n  at(col, row) {\n    return this.squares[col][row || 0];\n  }\n\n  /**\n   * Call fn on every square, column major.\n   * @param {function} fn function(Square, col, row)\n   * Iteration will stop if fn returns true.\n   * @return {boolean} true if fn() returns true, false otherwise\n   */\n  forEachSquare(fn) {\n    for (let c = 0; c < this.cols; c++)\n      for (let r = 0; r < this.rows; r++)\n        if (fn(this.squares[c][r], c, r))\n          return true;\n    return false;\n  }\n\n  /**\n   * Call fn(square, col, row) on every square that has a tile\n   * @param {function} fn function(Square, col, row)\n   * Iteration will stop if the function returns true.\n   * @return {boolean} true if fn() returns true, false otherwise\n   */\n  forEachTiledSquare(fn) {\n    return this.forEachSquare((square, c, r) => {\n      if (square.tile)\n        return fn(square, c, r);\n      return false;\n    });\n  }\n\n  /**\n   * Call fn(square, col, row) on every square that has no tile.\n   * @param {function} fn function(Square, col, row)\n   * Iteration will stop if the function returns true.\n   * @return {boolean} true if fn() returns true, false otherwise\n   */\n  forEachEmptySquare(fn) {\n    return this.forEachSquare((square, c, r) => {\n      if (!square.tile)\n        return fn(square, c, r);\n      return false;\n    });\n  }\n\n  /**\n   * Get the number of squares currently occupied by a tile\n   * @return {number} number of occupied squares\n   */\n  squaresUsed() {\n    let count = 0;\n    this.forEachTiledSquare(() => {\n      count++;\n      return false;\n    });\n    return count;\n  }\n\n  /**\n   * Get a list of the tiles placed on the surface\n   * @return {Tile[]} list of placed tiles\n   */\n  tiles() {\n    const tiles = [];\n    this.forEachTiledSquare(square => {\n      tiles.push(square.tile);\n      return false;\n    });\n    return tiles;\n  }\n\n  /**\n   * Remove all tiles from the surface, return a list of tiles\n   * removed;\n   */\n  empty() {\n    const removed = [];\n    this.forEachTiledSquare(square => {\n      removed.push(square.tile);\n      square.unplaceTile();\n    });\n    return removed;\n  }\n\n  /**\n   * Get the total of the scoring tiles placed on the\n   * surface. DOES NOT APPLY SQUARE MULTIPLIERS.\n   * @return {number} total score\n   */\n  score() {\n    return this.tiles().reduce((s, tile) => s + tile.score, 0);\n  }\n\n  /**\n   * Determine if the surface is empty of tiles\n   * @return {boolean} true if surface is empty\n   */\n  isEmpty() {\n    return this.tiles().length === 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Surface.js?");

/***/ }),

/***/ "./src/game/Tile.js":
/*!**************************!*\
  !*** ./src/game/Tile.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tile\": () => (/* binding */ Tile)\n/* harmony export */ });\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/**\n * A tile in a LetterBag, on a Board, or on a Rack, or during best move\n * computation.\n */\nclass Tile {\n\n  // Note that we do NOT use the field syntax for the fields that\n  // are serialised. If we do that, then the constructor blows the\n  // field away when loading using CBOR.\n\n  /**\n   * @param {Tile|object} spec optional Tile to copy or spec of tile\n   */\n  constructor(spec) {\n\n    /**\n     * Character(s) represented by this tile.\n     * Caution; during gameplay, `letter` for a blank will be set\n     * to a letter chosen by the player. When the tile is returned\n     * to the rack, the letter will be reset to \" \" as isBlank is true.\n     * However the letter will stick to the Tile when it is sent to\n     * the server as part of a move. Henceforward that Tile will\n     * be locked to the chosen letter on the server side.\n     * @member {string}\n     */\n    this.letter = spec.letter;\n\n    /**\n     * Value of this tile\n     * @member {number}\n     */\n    this.score = spec.score || 0;\n\n    if (typeof spec.col !== \"undefined\")\n      /**\n       * Column where the tile is placed\n       * @member {number?}\n       */\n      this.col = spec.col;\n\n    if (typeof spec.row !== \"undefined\")\n      /**\n       * Row where the tile is placed\n       * @member {number?}\n       */\n      this.row = spec.row;\n\n    if (spec.isBlank)\n      /**\n       * True if this tile is a blank (irresepective of letter)\n       * @member {boolean?}\n       */\n      this.isBlank = true;\n\n    if (spec.isLocked)\n      /**\n       * True if the tile is locked to a surface and cannot be moved.\n       * @member {boolean?}\n       */\n      this.isLocked = true;\n  }\n\n  /**\n   * Fix a tile to look like the given tile.\n   * @param {Tile} tile the tile to copy\n   * @return {Tile} this\n   */\n  copy(tile) {\n    this.reset();\n    if (tile.isBlank)\n      this.isBlank = true;\n    else\n      delete this.isBlank;\n    this.letter = tile.letter;\n    this.score = tile.score;\n    if (typeof tile.col !== \"undefined\")\n      this.col = tile.col;\n    if (typeof tile.row !== \"undefined\")\n      this.row = tile.row;\n    return this;\n  }\n\n  /**\n   * Remove letter cast and positional information from the tile e.g. before\n   * returning it to the bag or rack.\n   * @param {boolean?} wild true if this tile needs to be masked. Wild tiles\n   * are used on the client side to mask the contents of the letter bag and\n   * other players racks.\n   * @return {Tile} this\n   */\n  reset(wild) {\n    delete this.isLocked;\n    delete this.row;\n    delete this.col;\n    if (wild) {\n      this.letter = '#';\n      this.score = 0;\n    }\n    else if (this.isBlank)\n      this.letter = \" \";\n\n    return this;\n  }\n\n  /* c8 ignore start */\n\n  /**\n   * String representation for debugging\n   */\n  stringify() {\n    const letter = this.isBlank ? this.letter.toLowerCase() : this.letter;\n    const brackets = this.isLocked ? \"<>\" : \"[]\";\n    const pos = (typeof this.col === \"number\" ? `@${this.col}` : \"\")\n          + (typeof this.row === \"number\" ? `,${this.row}` : \"\");\n    return `${brackets.charAt(0)}${letter}${pos}${brackets.charAt(1)}`;\n  }\n  /* c8 ignore stop */\n}\n\n/**\n * Compare tiles by letter, for sorting. The letter assigned\n * to a blank is ignored.\n * @param {Tile} a first tile\n * @param {Tile} b second tile\n * @return {number} value suitable for use in Array.sort()\n */\nTile.cmp = (a, b) => {\n  if (a.isBlank && b.isBlank) return 0;\n  if (a.isBlank) return -1;\n  if (b.isBlank) return 1;\n  if (a.letter < b.letter) return -1;\n  if (a.letter > b.letter) return 1;\n  return 0;\n};\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Tile.js?");

/***/ }),

/***/ "./src/game/Turn.js":
/*!**************************!*\
  !*** ./src/game/Turn.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Turn\": () => (/* binding */ Turn)\n/* harmony export */ });\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ \"./src/game/Tile.js\");\n/* harmony import */ var _Move_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Move.js */ \"./src/game/Move.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n\n\n\n/**\n * Despite the name, a Turn is used not just as a historical record\n * of a player's turn (such as a play or a swap) but also for other\n * results from commands sent to the server, such as challenges.\n * @extends Move\n */\nclass Turn extends _Move_js__WEBPACK_IMPORTED_MODULE_1__.Move {\n  /**\n   * The 'type' of the turn.\n   * @member {Turns}\n   */\n  type;\n\n  /**\n   * Key of the game\n   * @member {Key}\n   */\n  gameKey;\n\n  /**\n   * Key of the player who has been affected by the turn. Normally\n   * this is the player who made the Move that resulted in the Turn,\n   * but in the case of a challenge it is the player who was\n   * challenged.\n   * @member {Key}\n   */\n  playerKey;\n\n  /**\n   * Key of the next player who's turn it is\n   * @member {Key}\n   */\n  nextToGoKey;\n\n  /**\n   * Time the turn was finished, assigned by the server.\n   * @member {number}\n   */\n  timestamp;\n\n  /**\n   * @param {Game} game the game this is a turn in.\n   * @param {object} params parameters. Any field with the same name\n   * as a member (or a member of {@linkcode Move}) will initialise\n   * that member.\n   */\n  constructor(params) {\n    super(params);\n\n    this.gameKey = params.gameKey;\n    this.type = params.type;\n    this.playerKey = params.playerKey;\n    this.nextToGoKey = params.nextToGoKey;\n    this.timestamp = params.timestamp || Date.now();\n\n    if (params.replacements)\n      /**\n       * List of tiles drawn from the bag to replace the tiles played\n       * in this turn. These tiles will not have positions.\n       * @member {Tile[]?}\n       */\n      this.replacements = params.replacements.map(\n        tilespec => new _Tile_js__WEBPACK_IMPORTED_MODULE_0__.Tile(tilespec));\n\n    if (params.challengerKey)\n      /**\n       * For `Game.Turns.CHALLENGE_WON` and `Game.Turns.CHALLENGE_LOST`,\n       * the key of the player who challenged. playerkey in this case\n       * will be the player who's play was challenged (always the\n       * previous player)\n       * @member {Key?}\n       */\n      this.challengerKey = params.challengerKey;\n\n    if (params.endState)\n      /**\n       * String describing the reason the game ended. Only used when\n       * type==Game.Turns.GAME_ENDED\n       * @member {State?}\n       */\n      this.endState = params.endState;\n\n    if (params.passes && params.passes > 0)\n      /**\n       * Number of passes the player had before this play. Required\n       * for undo.\n       * @member {number?}\n       */\n      this.passes = params.passes;\n  }\n\n  /**\n   * Create simple flat structure describing a subset of the turn\n   * state. This is used for sending minimal turn information to\n   * the `games` interface using JSON.\n   */\n  serialisable() {\n    return {\n      // Fields that are not used by the `games` interface are not\n      // sent\n      type: this.type,\n      timestamp: this.timestamp\n    };\n  }\n\n  /**\n   * Construct a player object from a structure generated by\n   * serialisable()\n   * @param {object} simple object generated by serialisable()\n   * @param {object} factory Game class to be used as factory\n   */\n  static fromSerialisable(simple, factory) {\n    return new factory.Turn(simple);\n  }\n\n  /* c8 ignore start */\n\n  /**\n   * String representation for debugging\n   */\n  stringify() {\n    let s = `Turn ${this.type} ${this.playerKey}`;\n    if (this.challengerKey)\n      s += ` by ${this.challengerKey}`;\n    if (this.nextToGoKey && this.nextToGoKey !== this.playerKey)\n      s += ` ->${this.nextToGoKey}`;\n\n    if (typeof this.score === \"object\")\n      s += ` (${this.score.tiles||0},${this.score.time||0})`;\n    else if (typeof this.score === \"number\")\n      s += ` (${this.score})`;\n\n    if (this.placements)\n      s += \" place\" + this.placements.map(t => t.stringify(true));\n\n    if (this.words)\n      s += ' \"' + this.words.map(w => w.word) + '\"';\n\n    if (this.replacements)\n      s += \" replace\" + this.replacements.map(t => t.stringify(true));\n\n    if (this.penalty === \"Miss next turn\"/*Game.Penalty.MISS*/)\n      s += ` MISS`;\n\n    if (this.endState)\n      s += ` ${this.endState}`;\n\n    return s;\n  }\n\n  /* c8 ignore stop */\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Turn.js?");

/***/ }),

/***/ "./src/game/Undo.js":
/*!**************************!*\
  !*** ./src/game/Undo.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Undo\": () => (/* binding */ Undo)\n/* harmony export */ });\n/* harmony import */ var _common_Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Utils.js */ \"./src/common/Utils.js\");\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Game.js */ \"./src/game/Game.js\");\n/*Copyright (C) 2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n/* global assert */\n\n\nconst Tile = _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.CLASSES.Tile;\n\n  /**\n   * Methods that provide undo/redo functionality for\n   * {@linkcode Game}. Requires {@linkcode game/Commands} to be mixed in.\n   * @mixin game/Undo\n   */\nconst Undo = superclass => class extends superclass {\n\n  /**\n   * Undo a swap. Resets the game state as if it had never happened.\n   * @instance\n   * @memberof game/Undo\n   * @param {Turn} turn the Turn to unplay\n   */\n  unswap(turn) {\n    this.state = _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.PLAYING;\n    const player = this.getPlayerWithKey(turn.playerKey);\n    this.rackToBag(turn.replacements, player);\n    this.bagToRack(turn.placements, player);\n    player.passes--;\n    this.whosTurnKey = player.key;\n  }\n\n  /**\n   * Undo a play. Resets the game state as if it had never happened.\n   * @instance\n   * @memberof game/Undo\n   * @param {Turn} turn the Turn to unplay\n   */\n  unplay(turn) {\n    this.state = _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.PLAYING;\n    const player = this.getPlayerWithKey(turn.playerKey);\n    if (turn.replacements)\n      this.rackToBag(turn.replacements, player);\n    if (turn.placements)\n      this.boardToRack(turn.placements, player);\n    player.score -= turn.score;\n    player.passes = turn.prepasses || 0;\n    this.whosTurnKey = player.key;\n  }\n\n  /**\n   * Undo a game over confirmation.\n   * Resets the game state as if it had never happened.\n   * @instance\n   * @memberof game/Undo\n   * @param {Turn} turn the Turn to unplay\n   */\n  unconfirmGameOver(turn) {\n    // Re-adjust scores from the deltas\n    for (const delta of turn.score) {\n      const player = this.getPlayerWithKey(delta.key);\n      assert(player, delta.key);\n      player.score -= (delta.time || 0) + (delta.tiles || 0);\n    }\n    this.state = _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.PLAYING;\n    // TODO: Notify\n    // TODO: reset the clock\n  }\n\n  /**\n   * Undo a TOOK_BACK or CHALLENGE_WON.\n   * Resets the game state as if it had never happened.\n   * @instance\n   * @memberof game/Undo\n   * @param {Turn} turn the Turn to unplay\n   */\n  untakeBack(turn) {\n    this.state = _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.PLAYING;\n    const player = this.getPlayerWithKey(turn.playerKey);\n    if (turn.placements)\n      this.rackToBoard(turn.placements, player);\n    if (turn.replacements)\n      this.bagToRack(turn.replacements, player);\n    player.score -= turn.score;\n    this.whosTurnKey = this.nextPlayer(player).key;\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"\\tplayer now\", this.whosTurnKey, turn);\n  }\n\n  /**\n   * Undo a pass. Resets the game stat as if it had never happened.\n   * @instance\n   * @memberof game/Undo\n   * @param {Turn} turn the Turn to unplay\n   */\n  unpass(turn) {\n    this.state = _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.State.PLAYING;\n    const player = this.getPlayerWithKey(turn.playerKey);\n    player.passes--;\n    this.whosTurnKey = player.key;\n    // TODO: Notify\n  }\n\n  /**\n   * Unplay a LOST challenge (won challenges are handled in untakeBack).\n   * Resets the game state as if it had never happened.\n   * @instance\n   * @memberof game/Undo\n   * @param {Turn} turn the Turn to unplay\n   */\n  unchallenge(turn) {\n    const player = this.getPlayerWithKey(turn.challengerKey);\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"\\t\", (0,_common_Utils_js__WEBPACK_IMPORTED_MODULE_0__.stringify)(player), \"regained\", turn.score);\n    player.score -= turn.score;\n    // TODO: Notify\n  }\n\n  /**\n   * Undo the most recent turn. Resets the play state as if the turn\n   * had never happened. Sends a Game.Notify.UNDONE to all listeners,\n   * passing the Turn that was unplayed.\n   * @instance\n   * @memberof game/Undo\n   * @param {Turn} turn the turn to undo\n   * @param {boolean?} quiet if true, don't perform any saves\n   * or notifications.\n   * the board and rack. If false, saves the game.\n   * @return {Promise} promise resolving to undefined\n   */\n  undo(turn, quiet) {\n    assert(this.allowUndo, \"Cannot Undo\");\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"un-\", turn.type);\n    switch (turn.type) {\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.SWAPPED:\n      this.unswap(turn, quiet);\n      break;\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PASSED:\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.TIMED_OUT:\n      this.unpass(turn, quiet);\n      break;\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PLAYED:\n      this.unplay(turn, quiet);\n      break;\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.TOOK_BACK:\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_WON:\n      this.untakeBack(turn, quiet);\n      break;\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.GAME_ENDED:\n      this.unconfirmGameOver(turn, quiet);\n      break;\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_LOST:\n      this.unchallenge(turn, quiet);\n      break;\n    default:\n      assert.fail(`Unknown turn type '${turn.type}'`);\n    }\n\n    if (quiet)\n      return Promise.resolve();\n\n    return this.save()\n    .then(() => this.notifyAll(_Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Notify.UNDONE, turn));\n  }\n\n  /**\n   * Replay the given turn back into the game\n   * @instance\n   * @memberof game/Undo\n   * param {Turn} trun turn to redo\n   * @return {Promise} promise resolving to undefined\n   */\n  redo(turn) {\n    const player = this.getPlayerWithKey(turn.playerKey);\n    /* c8 ignore next 2 */\n    if (this._debug)\n      this._debug(\"REDO\", turn.type, turn);\n    switch (turn.type) {\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.SWAPPED:\n      // Remove and return the expected tiles to the the unshaken bag\n      // to ensure replay order. We have to do this so the next play on the\n      // undo stack is also redoable.\n      this.letterBag.predictable = true;\n      this.letterBag.removeTiles(turn.replacements);\n      this.letterBag.returnTiles(turn.replacements.map(t => new Tile(t)));\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\t-- swap\");\n      return this.swap(player, turn.placements)\n      .then(() => delete this.letterBag.predictable);\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PLAYED:\n      this.letterBag.predictable = true;\n      // Remove and return\n      this.letterBag.removeTiles(turn.replacements);\n      this.letterBag.returnTiles(turn.replacements.map(t => new Tile(t)));\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\t-- play\");\n      return this.play(player, turn)\n      .then(() => delete this.letterBag.predictable);\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.PASSED:\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.TIMED_OUT:\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\t-- pass\");\n      return this.pass(player, turn.type);\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.TOOK_BACK:\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\t-- takeBack\");\n      return this.takeBack(player, turn.type);\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_WON:\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.CHALLENGE_LOST:\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\t-- challenge\");\n      return this.challenge(\n        this.getPlayerWithKey(turn.challengerKey), player);\n    case _Game_js__WEBPACK_IMPORTED_MODULE_1__.Game.Turns.GAME_ENDED:\n      /* c8 ignore next 2 */\n      if (this._debug)\n        this._debug(\"\\t-- confirmGameOver\");\n      return this.confirmGameOver(player, turn.endState);\n    }\n    /* c8 ignore next */\n    throw Error(\"Unrecognised turn type\");\n  }\n};\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/Undo.js?");

/***/ }),

/***/ "./src/game/loadDictionary.js":
/*!************************************!*\
  !*** ./src/game/loadDictionary.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadDictionary\": () => (/* binding */ loadDictionary)\n/* harmony export */ });\n/* harmony import */ var _cdot_dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cdot/dictionary */ \"./node_modules/@cdot/dictionary/dist/mjs/index.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\n  License MIT. See README.md at the root of this distribution for full copyright\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\n\n\nconst cache = {};\n/* global Platform */\n\n/** @module */\n\n/**\n * Load dictionaries and optional .white in a platform indepedent way\n */\n\n/**\n * Promise to load a dictionary. A dictionary can consist of a\n * `.dict` (DAWG) file, a `.white` (whitelist, text) file, or\n * both.\n * @param {string} name name of the dictionary to load. This can\n * be a be a full path to a .dict file, or it can be a simple\n * dictionary name, in which case the dictionary will be loaded from\n * `Platform.getFilePath(\"dictionaries\")`.\n * @return {Promise} Promise that resolves to a new {@linkcode Dictionary}\n * or undefined if a dictionary of that name could not be loaded.\n */\nfunction loadDictionary(name) {\n  let path = Platform.parsePath(name);\n  //console.log(name,\"=>\",path);\n  if (path.root === \"\" && path.dir === \"\" && path.ext === \"\") {\n    // Simple name, load from the dictionaries path. /ignore is a\n    // placeholder\n    path = Platform.parsePath(Platform.getFilePath(\"dictionaries/ignore\"));\n    path.name = name;\n    path.ext = \".dict\";\n  } else if (path.ext === \"\") {\n    // root and/or dir, but no ext\n    path.ext = \".dict\";\n  } else\n    name = path.name;\n  // Get rid of path.base so Platform.formatPath uses name and ext\n  delete path.base;\n\n  if (cache[name])\n    return Promise.resolve(cache[name]);\n\n  let dict;\n  const fp = Platform.formatPath(path);\n  return Platform.readBinaryFile(fp)\n  .then(buffer => {\n    dict = new _cdot_dictionary__WEBPACK_IMPORTED_MODULE_0__.Dictionary(name);\n    dict.loadDAWG(buffer.buffer);\n  })\n  .catch(e => {\n    // Mostly harmless, .dict load failed, relying on .white\n    console.error(\"Failed to read\", fp, e);\n  })\n  .then(() => {\n    path.ext = \".white\";\n    const wp = Platform.formatPath(path);\n    return Platform.readFile(wp)\n    .then(text => {\n      if (!dict)\n        dict = new _cdot_dictionary__WEBPACK_IMPORTED_MODULE_0__.Dictionary(name);\n      const words = text\n            .toString()\n            .toUpperCase()\n            .split(/\\r?\\n/)\n            .map(w => w.replace(/\\s.*$/, \"\"))\n            .filter(line => line.length > 0)\n            .sort();\n      words.forEach(w => dict._addWord(w));\n      //console.debug(\"Added\", added, \"whitelisted words\");\n    })\n    .catch(() => {\n      // Mostly harmless, whitelist load failed, relying on .dict\n      //console.debug(\"Failed to read\", wp, e);\n    });\n  })\n  .then(() => {\n    if (dict) {\n      // one of .dict or .white (or both) loaded\n      // Add bidirectional traversal links\n      dict.addLinks();\n      cache[name] = dict;\n      //console.debug(`Loaded dictionary ${name}`);\n    }\n    return dict;\n  });\n}\n\n\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/loadDictionary.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_cdot_cbor_dist_mjs_index_js-node_modules_cdot_dictionary_dist_mjs_index_js","findBestPlay"], () => (__webpack_require__("./src/backend/findBestPlayWorker.js")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "standalone/" + chunkId + "._StandaloneGameUI.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "/../../";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"src_backend_findBestPlayWorker_js": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = window["webpackChunk_cdot_xanado"] = window["webpackChunk_cdot_xanado"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return Promise.all([
/******/ 				__webpack_require__.e("vendors-node_modules_cdot_cbor_dist_mjs_index_js-node_modules_cdot_dictionary_dist_mjs_index_js"),
/******/ 				__webpack_require__.e("findBestPlay")
/******/ 			]).then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;